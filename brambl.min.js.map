{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///brambl.min.js","webpack:///webpack/bootstrap 9849ad196c00bd70d8c0","webpack:///./src/bundle.js","webpack:///./src/js/brambl.graph.js","webpack:///./~/d3-force/build/d3-force.js","webpack:///./~/d3-quadtree/build/d3-quadtree.js","webpack:///./~/d3-collection/build/d3-collection.js","webpack:///./~/d3-dispatch/build/d3-dispatch.js","webpack:///./~/d3-timer/build/d3-timer.js","webpack:///./src/js/data.json"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","Graph","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","d3","data","selector","options","container","document","querySelector","value","redraw","context","clearRect","width","height","beginPath","links","forEach","drawLink","stroke","nodes","drawNode","fill","d","moveTo","source","x","y","lineTo","arc","Math","PI","canvas","createElement","appendChild","getContext","simulation","forceSimulation","force","forceLink","forceManyBody","forceCenter","on","distance","global","d3Quadtree","d3Collection","d3Dispatch","d3Timer","center","node","n","sx","sy","initialize","_","arguments","constant","jiggle","random","vx","vy","collide","radius","apply","quad","x0","y0","x1","y1","rj","r","ri","xi","yi","index","l","sqrt","strength","ri2","tree","k","iterations","quadtree","visitAfter","prepare","radii","visit","Array","link","defaultStrength","min","count","alpha","b","distances","strengths","bias","nodeById","map","get","initializeStrength","initializeDistance","x$1","y$1","step","tick","event","alphaMin","stepper","stop","alphaTarget","alphaDecay","forces","each","fx","velocityDecay","fy","initializeNodes","isNaN","initialRadius","angle","initialAngle","cos","sin","initializeForce","pow","timer","dispatch","restart","name","remove","set","find","dx","dy","d2","closest","Infinity","manyBody","accumulate","q","next","x2","w","theta2","distanceMax2","distanceMin2","distanceMin","distanceMax","theta","x$2","xz","y$2","yz","forceCollide","forceX","forceY","tree_add","_x","_y","add","cover","parent","xm","ym","xp","yp","right","bottom","j","_root","leaf","_x0","_y0","_x1","_y1","addAll","tree_cover","floor","z","tree_data","push","tree_extent","undefined","Quad","tree_find","y2","x3","y3","quads","pop","tree_remove","retainer","previous","removeAll","tree_root","tree_size","size","tree_visit","callback","child","tree_visitAfter","defaultX","tree_x","defaultY","tree_y","Quadtree","NaN","leaf_copy","copy","treeProto","extent","Map","object","f","isArray","o","nest","array","depth","createResult","setResult","keys","rollup","sortValues","sort","keyValue","values","valuesByKey","result","entries","sortKey","sortKeys","v","a","createObject","setObject","createMap","setMap","order","Set","prefix","constructor","has","property","clear","slice","empty","proto","t","Error","Dispatch","parseTypenames","typenames","types","trim","split","indexOf","hasOwnProperty","type","noop","concat","typename","T","that","args","now","clockNow","setFrame","clearNow","clock","clockSkew","Timer","_call","_time","_next","delay","time","timerFlush","frame","e","taskHead","wake","clockLast","timeout","nap","poke","pokeDelay","t0","t2","t1","taskTail","sleep","clearTimeout","setTimeout","interval","clearInterval","setInterval","timeout$1","elapsed","interval$1","total","performance","Date","requestAnimationFrame"],"mappings":"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","file":"brambl.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Brambl\"] = factory();\n\telse\n\t\troot[\"Brambl\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Brambl\"] = factory();\n\telse\n\t\troot[\"Brambl\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t// Main export\n\tmodule.exports = {\n\t  Graph: __webpack_require__(1)\n\t};\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar d3 = __webpack_require__(2);\n\tvar data = __webpack_require__(7);\n\t\n\tvar Graph = function () {\n\t\n\t  /* Create an instance of a brambl \n\t   *\n\t   */\n\t  function Graph(selector, options) {\n\t    _classCallCheck(this, Graph);\n\t\n\t    this.selector = selector;\n\t    this.options = options || {};\n\t    this.container = document.querySelector(selector);\n\t  }\n\t\n\t  // Lots of horrible side effects in here at the moment - this is just\n\t  // because the code here is largely a copy/paste job from a d3 example\n\t  // and this whole thing is basically just in \"bootstrapping mode\" at the \n\t  // moment while I get the env set up the way I want it. \n\t  //\n\t  // Don't judge me!!\n\t  //\n\t\n\t\n\t  _createClass(Graph, [{\n\t    key: 'start',\n\t    value: function start() {\n\t\n\t      var canvas = document.createElement('canvas');\n\t      container.appendChild(canvas);\n\t\n\t      var context = canvas.getContext(\"2d\");\n\t\n\t      var width = canvas.width = 1000;\n\t      var height = canvas.height = 500;\n\t\n\t      var simulation = d3.forceSimulation().force(\"link\", d3.forceLink().id(function (d) {\n\t        return d.id;\n\t      })).force(\"charge\", d3.forceManyBody()).force(\"center\", d3.forceCenter(width / 2, height / 2));\n\t\n\t      simulation.nodes(data.nodes).on(\"tick\", redraw);\n\t\n\t      simulation.force(\"link\").links(data.links).distance(function (d) {\n\t        return 100;\n\t      });\n\t\n\t      function redraw() {\n\t        context.clearRect(0, 0, width, height);\n\t\n\t        context.beginPath();\n\t        data.links.forEach(drawLink);\n\t        context.stroke();\n\t\n\t        context.beginPath();\n\t        data.nodes.forEach(drawNode);\n\t        context.fill();\n\t      }\n\t\n\t      function drawLink(d) {\n\t        context.moveTo(d.source.x, d.source.y);\n\t        context.lineTo(d.target.x, d.target.y);\n\t      }\n\t\n\t      function drawNode(d) {\n\t        context.moveTo(d.x + 3, d.y);\n\t        context.arc(d.x, d.y, 20, 0, 2 * Math.PI);\n\t      }\n\t    }\n\t  }]);\n\t\n\t  return Graph;\n\t}();\n\t\n\tmodule.exports = Graph;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// https://d3js.org/d3-force/ Version 1.0.2. Copyright 2016 Mike Bostock.\n\t(function (global, factory) {\n\t   true ? factory(exports, __webpack_require__(3), __webpack_require__(4), __webpack_require__(5), __webpack_require__(6)) :\n\t  typeof define === 'function' && define.amd ? define(['exports', 'd3-quadtree', 'd3-collection', 'd3-dispatch', 'd3-timer'], factory) :\n\t  (factory((global.d3 = global.d3 || {}),global.d3,global.d3,global.d3,global.d3));\n\t}(this, function (exports,d3Quadtree,d3Collection,d3Dispatch,d3Timer) { 'use strict';\n\t\n\t  function center(x, y) {\n\t    var nodes;\n\t\n\t    if (x == null) x = 0;\n\t    if (y == null) y = 0;\n\t\n\t    function force() {\n\t      var i,\n\t          n = nodes.length,\n\t          node,\n\t          sx = 0,\n\t          sy = 0;\n\t\n\t      for (i = 0; i < n; ++i) {\n\t        node = nodes[i], sx += node.x, sy += node.y;\n\t      }\n\t\n\t      for (sx = sx / n - x, sy = sy / n - y, i = 0; i < n; ++i) {\n\t        node = nodes[i], node.x -= sx, node.y -= sy;\n\t      }\n\t    }\n\t\n\t    force.initialize = function(_) {\n\t      nodes = _;\n\t    };\n\t\n\t    force.x = function(_) {\n\t      return arguments.length ? (x = +_, force) : x;\n\t    };\n\t\n\t    force.y = function(_) {\n\t      return arguments.length ? (y = +_, force) : y;\n\t    };\n\t\n\t    return force;\n\t  }\n\t\n\t  function constant(x) {\n\t    return function() {\n\t      return x;\n\t    };\n\t  }\n\t\n\t  function jiggle() {\n\t    return (Math.random() - 0.5) * 1e-6;\n\t  }\n\t\n\t  function x(d) {\n\t    return d.x + d.vx;\n\t  }\n\t\n\t  function y(d) {\n\t    return d.y + d.vy;\n\t  }\n\t\n\t  function collide(radius) {\n\t    var nodes,\n\t        radii,\n\t        strength = 1,\n\t        iterations = 1;\n\t\n\t    if (typeof radius !== \"function\") radius = constant(radius == null ? 1 : +radius);\n\t\n\t    function force() {\n\t      var i, n = nodes.length,\n\t          tree,\n\t          node,\n\t          xi,\n\t          yi,\n\t          ri,\n\t          ri2;\n\t\n\t      for (var k = 0; k < iterations; ++k) {\n\t        tree = d3Quadtree.quadtree(nodes, x, y).visitAfter(prepare);\n\t        for (i = 0; i < n; ++i) {\n\t          node = nodes[i];\n\t          ri = radii[i], ri2 = ri * ri;\n\t          xi = node.x + node.vx;\n\t          yi = node.y + node.vy;\n\t          tree.visit(apply);\n\t        }\n\t      }\n\t\n\t      function apply(quad, x0, y0, x1, y1) {\n\t        var data = quad.data, rj = quad.r, r = ri + rj;\n\t        if (data) {\n\t          if (data.index > i) {\n\t            var x = xi - data.x - data.vx,\n\t                y = yi - data.y - data.vy,\n\t                l = x * x + y * y;\n\t            if (l < r * r) {\n\t              if (x === 0) x = jiggle(), l += x * x;\n\t              if (y === 0) y = jiggle(), l += y * y;\n\t              l = (r - (l = Math.sqrt(l))) / l * strength;\n\t              node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));\n\t              node.vy += (y *= l) * r;\n\t              data.vx -= x * (r = 1 - r);\n\t              data.vy -= y * r;\n\t            }\n\t          }\n\t          return;\n\t        }\n\t        return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;\n\t      }\n\t    }\n\t\n\t    function prepare(quad) {\n\t      if (quad.data) return quad.r = radii[quad.data.index];\n\t      for (var i = quad.r = 0; i < 4; ++i) {\n\t        if (quad[i] && quad[i].r > quad.r) {\n\t          quad.r = quad[i].r;\n\t        }\n\t      }\n\t    }\n\t\n\t    force.initialize = function(_) {\n\t      var i, n = (nodes = _).length; radii = new Array(n);\n\t      for (i = 0; i < n; ++i) radii[i] = +radius(nodes[i], i, nodes);\n\t    };\n\t\n\t    force.iterations = function(_) {\n\t      return arguments.length ? (iterations = +_, force) : iterations;\n\t    };\n\t\n\t    force.strength = function(_) {\n\t      return arguments.length ? (strength = +_, force) : strength;\n\t    };\n\t\n\t    force.radius = function(_) {\n\t      return arguments.length ? (radius = typeof _ === \"function\" ? _ : constant(+_), force) : radius;\n\t    };\n\t\n\t    return force;\n\t  }\n\t\n\t  function index(d, i) {\n\t    return i;\n\t  }\n\t\n\t  function link(links) {\n\t    var id = index,\n\t        strength = defaultStrength,\n\t        strengths,\n\t        distance = constant(30),\n\t        distances,\n\t        nodes,\n\t        count,\n\t        bias,\n\t        iterations = 1;\n\t\n\t    if (links == null) links = [];\n\t\n\t    function defaultStrength(link) {\n\t      return 1 / Math.min(count[link.source.index], count[link.target.index]);\n\t    }\n\t\n\t    function force(alpha) {\n\t      for (var k = 0, n = links.length; k < iterations; ++k) {\n\t        for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {\n\t          link = links[i], source = link.source, target = link.target;\n\t          x = target.x + target.vx - source.x - source.vx || jiggle();\n\t          y = target.y + target.vy - source.y - source.vy || jiggle();\n\t          l = Math.sqrt(x * x + y * y);\n\t          l = (l - distances[i]) / l * alpha * strengths[i];\n\t          x *= l, y *= l;\n\t          target.vx -= x * (b = bias[i]);\n\t          target.vy -= y * b;\n\t          source.vx += x * (b = 1 - b);\n\t          source.vy += y * b;\n\t        }\n\t      }\n\t    }\n\t\n\t    function initialize() {\n\t      if (!nodes) return;\n\t\n\t      var i,\n\t          n = nodes.length,\n\t          m = links.length,\n\t          nodeById = d3Collection.map(nodes, id),\n\t          link;\n\t\n\t      for (i = 0, count = new Array(n); i < n; ++i) {\n\t        count[i] = 0;\n\t      }\n\t\n\t      for (i = 0; i < m; ++i) {\n\t        link = links[i], link.index = i;\n\t        if (typeof link.source !== \"object\") link.source = nodeById.get(link.source);\n\t        if (typeof link.target !== \"object\") link.target = nodeById.get(link.target);\n\t        ++count[link.source.index], ++count[link.target.index];\n\t      }\n\t\n\t      for (i = 0, bias = new Array(m); i < m; ++i) {\n\t        link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);\n\t      }\n\t\n\t      strengths = new Array(m), initializeStrength();\n\t      distances = new Array(m), initializeDistance();\n\t    }\n\t\n\t    function initializeStrength() {\n\t      if (!nodes) return;\n\t\n\t      for (var i = 0, n = links.length; i < n; ++i) {\n\t        strengths[i] = +strength(links[i], i, links);\n\t      }\n\t    }\n\t\n\t    function initializeDistance() {\n\t      if (!nodes) return;\n\t\n\t      for (var i = 0, n = links.length; i < n; ++i) {\n\t        distances[i] = +distance(links[i], i, links);\n\t      }\n\t    }\n\t\n\t    force.initialize = function(_) {\n\t      nodes = _;\n\t      initialize();\n\t    };\n\t\n\t    force.links = function(_) {\n\t      return arguments.length ? (links = _, initialize(), force) : links;\n\t    };\n\t\n\t    force.id = function(_) {\n\t      return arguments.length ? (id = _, force) : id;\n\t    };\n\t\n\t    force.iterations = function(_) {\n\t      return arguments.length ? (iterations = +_, force) : iterations;\n\t    };\n\t\n\t    force.strength = function(_) {\n\t      return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant(+_), initializeStrength(), force) : strength;\n\t    };\n\t\n\t    force.distance = function(_) {\n\t      return arguments.length ? (distance = typeof _ === \"function\" ? _ : constant(+_), initializeDistance(), force) : distance;\n\t    };\n\t\n\t    return force;\n\t  }\n\t\n\t  function x$1(d) {\n\t    return d.x;\n\t  }\n\t\n\t  function y$1(d) {\n\t    return d.y;\n\t  }\n\t\n\t  var initialRadius = 10;\n\t  var initialAngle = Math.PI * (3 - Math.sqrt(5));\n\t  function simulation(nodes) {\n\t    var simulation,\n\t        alpha = 1,\n\t        alphaMin = 0.001,\n\t        alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),\n\t        alphaTarget = 0,\n\t        velocityDecay = 0.6,\n\t        forces = d3Collection.map(),\n\t        stepper = d3Timer.timer(step),\n\t        event = d3Dispatch.dispatch(\"tick\", \"end\");\n\t\n\t    if (nodes == null) nodes = [];\n\t\n\t    function step() {\n\t      tick();\n\t      event.call(\"tick\", simulation);\n\t      if (alpha < alphaMin) {\n\t        stepper.stop();\n\t        event.call(\"end\", simulation);\n\t      }\n\t    }\n\t\n\t    function tick() {\n\t      var i, n = nodes.length, node;\n\t\n\t      alpha += (alphaTarget - alpha) * alphaDecay;\n\t\n\t      forces.each(function(force) {\n\t        force(alpha);\n\t      });\n\t\n\t      for (i = 0; i < n; ++i) {\n\t        node = nodes[i];\n\t        if (node.fx == null) node.x += node.vx *= velocityDecay;\n\t        else node.x = node.fx, node.vx = 0;\n\t        if (node.fy == null) node.y += node.vy *= velocityDecay;\n\t        else node.y = node.fy, node.vy = 0;\n\t      }\n\t    }\n\t\n\t    function initializeNodes() {\n\t      for (var i = 0, n = nodes.length, node; i < n; ++i) {\n\t        node = nodes[i], node.index = i;\n\t        if (isNaN(node.x) || isNaN(node.y)) {\n\t          var radius = initialRadius * Math.sqrt(i), angle = i * initialAngle;\n\t          node.x = radius * Math.cos(angle);\n\t          node.y = radius * Math.sin(angle);\n\t        }\n\t        if (isNaN(node.vx) || isNaN(node.vy)) {\n\t          node.vx = node.vy = 0;\n\t        }\n\t      }\n\t    }\n\t\n\t    function initializeForce(force) {\n\t      if (force.initialize) force.initialize(nodes);\n\t      return force;\n\t    }\n\t\n\t    initializeNodes();\n\t\n\t    return simulation = {\n\t      tick: tick,\n\t\n\t      restart: function() {\n\t        return stepper.restart(step), simulation;\n\t      },\n\t\n\t      stop: function() {\n\t        return stepper.stop(), simulation;\n\t      },\n\t\n\t      nodes: function(_) {\n\t        return arguments.length ? (nodes = _, initializeNodes(), forces.each(initializeForce), simulation) : nodes;\n\t      },\n\t\n\t      alpha: function(_) {\n\t        return arguments.length ? (alpha = +_, simulation) : alpha;\n\t      },\n\t\n\t      alphaMin: function(_) {\n\t        return arguments.length ? (alphaMin = +_, simulation) : alphaMin;\n\t      },\n\t\n\t      alphaDecay: function(_) {\n\t        return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;\n\t      },\n\t\n\t      alphaTarget: function(_) {\n\t        return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;\n\t      },\n\t\n\t      velocityDecay: function(_) {\n\t        return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;\n\t      },\n\t\n\t      force: function(name, _) {\n\t        return arguments.length > 1 ? ((_ == null ? forces.remove(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);\n\t      },\n\t\n\t      find: function(x, y, radius) {\n\t        var i = 0,\n\t            n = nodes.length,\n\t            dx,\n\t            dy,\n\t            d2,\n\t            node,\n\t            closest;\n\t\n\t        if (radius == null) radius = Infinity;\n\t        else radius *= radius;\n\t\n\t        for (i = 0; i < n; ++i) {\n\t          node = nodes[i];\n\t          dx = x - node.x;\n\t          dy = y - node.y;\n\t          d2 = dx * dx + dy * dy;\n\t          if (d2 < radius) closest = node, radius = d2;\n\t        }\n\t\n\t        return closest;\n\t      },\n\t\n\t      on: function(name, _) {\n\t        return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);\n\t      }\n\t    };\n\t  }\n\t\n\t  function manyBody() {\n\t    var nodes,\n\t        node,\n\t        alpha,\n\t        strength = constant(-30),\n\t        strengths,\n\t        distanceMin2 = 1,\n\t        distanceMax2 = Infinity,\n\t        theta2 = 0.81;\n\t\n\t    function force(_) {\n\t      var i, n = nodes.length, tree = d3Quadtree.quadtree(nodes, x$1, y$1).visitAfter(accumulate);\n\t      for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);\n\t    }\n\t\n\t    function initialize() {\n\t      if (!nodes) return;\n\t      var i, n = nodes.length;\n\t      strengths = new Array(n);\n\t      for (i = 0; i < n; ++i) strengths[i] = +strength(nodes[i], i, nodes);\n\t    }\n\t\n\t    function accumulate(quad) {\n\t      var strength = 0, q, c, x, y, i;\n\t\n\t      // For internal nodes, accumulate forces from child quadrants.\n\t      if (quad.length) {\n\t        for (x = y = i = 0; i < 4; ++i) {\n\t          if ((q = quad[i]) && (c = q.value)) {\n\t            strength += c, x += c * q.x, y += c * q.y;\n\t          }\n\t        }\n\t        quad.x = x / strength;\n\t        quad.y = y / strength;\n\t      }\n\t\n\t      // For leaf nodes, accumulate forces from coincident quadrants.\n\t      else {\n\t        q = quad;\n\t        q.x = q.data.x;\n\t        q.y = q.data.y;\n\t        do strength += strengths[q.data.index];\n\t        while (q = q.next);\n\t      }\n\t\n\t      quad.value = strength;\n\t    }\n\t\n\t    function apply(quad, x1, _, x2) {\n\t      if (!quad.value) return true;\n\t\n\t      var x = quad.x - node.x,\n\t          y = quad.y - node.y,\n\t          w = x2 - x1,\n\t          l = x * x + y * y;\n\t\n\t      // Apply the Barnes-Hut approximation if possible.\n\t      // Limit forces for very close nodes; randomize direction if coincident.\n\t      if (w * w / theta2 < l) {\n\t        if (l < distanceMax2) {\n\t          if (x === 0) x = jiggle(), l += x * x;\n\t          if (y === 0) y = jiggle(), l += y * y;\n\t          if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);\n\t          node.vx += x * quad.value * alpha / l;\n\t          node.vy += y * quad.value * alpha / l;\n\t        }\n\t        return true;\n\t      }\n\t\n\t      // Otherwise, process points directly.\n\t      else if (quad.length || l >= distanceMax2) return;\n\t\n\t      // Limit forces for very close nodes; randomize direction if coincident.\n\t      if (quad.data !== node || quad.next) {\n\t        if (x === 0) x = jiggle(), l += x * x;\n\t        if (y === 0) y = jiggle(), l += y * y;\n\t        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);\n\t      }\n\t\n\t      do if (quad.data !== node) {\n\t        w = strengths[quad.data.index] * alpha / l;\n\t        node.vx += x * w;\n\t        node.vy += y * w;\n\t      } while (quad = quad.next);\n\t    }\n\t\n\t    force.initialize = function(_) {\n\t      nodes = _;\n\t      initialize();\n\t    };\n\t\n\t    force.strength = function(_) {\n\t      return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant(+_), initialize(), force) : strength;\n\t    };\n\t\n\t    force.distanceMin = function(_) {\n\t      return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);\n\t    };\n\t\n\t    force.distanceMax = function(_) {\n\t      return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);\n\t    };\n\t\n\t    force.theta = function(_) {\n\t      return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);\n\t    };\n\t\n\t    return force;\n\t  }\n\t\n\t  function x$2(x) {\n\t    var strength = constant(0.1),\n\t        nodes,\n\t        strengths,\n\t        xz;\n\t\n\t    if (typeof x !== \"function\") x = constant(x == null ? 0 : +x);\n\t\n\t    function force(alpha) {\n\t      for (var i = 0, n = nodes.length, node; i < n; ++i) {\n\t        node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;\n\t      }\n\t    }\n\t\n\t    function initialize() {\n\t      if (!nodes) return;\n\t      var i, n = nodes.length;\n\t      strengths = new Array(n);\n\t      xz = new Array(n);\n\t      for (i = 0; i < n; ++i) {\n\t        strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);\n\t      }\n\t    }\n\t\n\t    force.initialize = function(_) {\n\t      nodes = _;\n\t      initialize();\n\t    };\n\t\n\t    force.strength = function(_) {\n\t      return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant(+_), initialize(), force) : strength;\n\t    };\n\t\n\t    force.x = function(_) {\n\t      return arguments.length ? (x = typeof _ === \"function\" ? _ : constant(+_), initialize(), force) : x;\n\t    };\n\t\n\t    return force;\n\t  }\n\t\n\t  function y$2(y) {\n\t    var strength = constant(0.1),\n\t        nodes,\n\t        strengths,\n\t        yz;\n\t\n\t    if (typeof y !== \"function\") y = constant(y == null ? 0 : +y);\n\t\n\t    function force(alpha) {\n\t      for (var i = 0, n = nodes.length, node; i < n; ++i) {\n\t        node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;\n\t      }\n\t    }\n\t\n\t    function initialize() {\n\t      if (!nodes) return;\n\t      var i, n = nodes.length;\n\t      strengths = new Array(n);\n\t      yz = new Array(n);\n\t      for (i = 0; i < n; ++i) {\n\t        strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);\n\t      }\n\t    }\n\t\n\t    force.initialize = function(_) {\n\t      nodes = _;\n\t      initialize();\n\t    };\n\t\n\t    force.strength = function(_) {\n\t      return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant(+_), initialize(), force) : strength;\n\t    };\n\t\n\t    force.y = function(_) {\n\t      return arguments.length ? (y = typeof _ === \"function\" ? _ : constant(+_), initialize(), force) : y;\n\t    };\n\t\n\t    return force;\n\t  }\n\t\n\t  exports.forceCenter = center;\n\t  exports.forceCollide = collide;\n\t  exports.forceLink = link;\n\t  exports.forceManyBody = manyBody;\n\t  exports.forceSimulation = simulation;\n\t  exports.forceX = x$2;\n\t  exports.forceY = y$2;\n\t\n\t  Object.defineProperty(exports, '__esModule', { value: true });\n\t\n\t}));\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// https://d3js.org/d3-quadtree/ Version 1.0.1. Copyright 2016 Mike Bostock.\n\t(function (global, factory) {\n\t   true ? factory(exports) :\n\t  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t  (factory((global.d3 = global.d3 || {})));\n\t}(this, function (exports) { 'use strict';\n\t\n\t  function tree_add(d) {\n\t    var x = +this._x.call(null, d),\n\t        y = +this._y.call(null, d);\n\t    return add(this.cover(x, y), x, y, d);\n\t  }\n\t\n\t  function add(tree, x, y, d) {\n\t    if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points\n\t\n\t    var parent,\n\t        node = tree._root,\n\t        leaf = {data: d},\n\t        x0 = tree._x0,\n\t        y0 = tree._y0,\n\t        x1 = tree._x1,\n\t        y1 = tree._y1,\n\t        xm,\n\t        ym,\n\t        xp,\n\t        yp,\n\t        right,\n\t        bottom,\n\t        i,\n\t        j;\n\t\n\t    // If the tree is empty, initialize the root as a leaf.\n\t    if (!node) return tree._root = leaf, tree;\n\t\n\t    // Find the existing leaf for the new point, or add it.\n\t    while (node.length) {\n\t      if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;\n\t      if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;\n\t      if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;\n\t    }\n\t\n\t    // Is the new point is exactly coincident with the existing point?\n\t    xp = +tree._x.call(null, node.data);\n\t    yp = +tree._y.call(null, node.data);\n\t    if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;\n\t\n\t    // Otherwise, split the leaf node until the old and new point are separated.\n\t    do {\n\t      parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);\n\t      if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;\n\t      if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;\n\t    } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));\n\t    return parent[j] = node, parent[i] = leaf, tree;\n\t  }\n\t\n\t  function addAll(data) {\n\t    var d, i, n = data.length,\n\t        x,\n\t        y,\n\t        xz = new Array(n),\n\t        yz = new Array(n),\n\t        x0 = Infinity,\n\t        y0 = Infinity,\n\t        x1 = -Infinity,\n\t        y1 = -Infinity;\n\t\n\t    // Compute the points and their extent.\n\t    for (i = 0; i < n; ++i) {\n\t      if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;\n\t      xz[i] = x;\n\t      yz[i] = y;\n\t      if (x < x0) x0 = x;\n\t      if (x > x1) x1 = x;\n\t      if (y < y0) y0 = y;\n\t      if (y > y1) y1 = y;\n\t    }\n\t\n\t    // If there were no (valid) points, inherit the existing extent.\n\t    if (x1 < x0) x0 = this._x0, x1 = this._x1;\n\t    if (y1 < y0) y0 = this._y0, y1 = this._y1;\n\t\n\t    // Expand the tree to cover the new points.\n\t    this.cover(x0, y0).cover(x1, y1);\n\t\n\t    // Add the new points.\n\t    for (i = 0; i < n; ++i) {\n\t      add(this, xz[i], yz[i], data[i]);\n\t    }\n\t\n\t    return this;\n\t  }\n\t\n\t  function tree_cover(x, y) {\n\t    if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points\n\t\n\t    var x0 = this._x0,\n\t        y0 = this._y0,\n\t        x1 = this._x1,\n\t        y1 = this._y1;\n\t\n\t    // If the quadtree has no extent, initialize them.\n\t    // Integer extent are necessary so that if we later double the extent,\n\t    // the existing quadrant boundaries dont change due to floating point error!\n\t    if (isNaN(x0)) {\n\t      x1 = (x0 = Math.floor(x)) + 1;\n\t      y1 = (y0 = Math.floor(y)) + 1;\n\t    }\n\t\n\t    // Otherwise, double repeatedly to cover.\n\t    else if (x0 > x || x > x1 || y0 > y || y > y1) {\n\t      var z = x1 - x0,\n\t          node = this._root,\n\t          parent,\n\t          i;\n\t\n\t      switch (i = (y < (y0 + y1) / 2) << 1 | (x < (x0 + x1) / 2)) {\n\t        case 0: {\n\t          do parent = new Array(4), parent[i] = node, node = parent;\n\t          while (z *= 2, x1 = x0 + z, y1 = y0 + z, x > x1 || y > y1);\n\t          break;\n\t        }\n\t        case 1: {\n\t          do parent = new Array(4), parent[i] = node, node = parent;\n\t          while (z *= 2, x0 = x1 - z, y1 = y0 + z, x0 > x || y > y1);\n\t          break;\n\t        }\n\t        case 2: {\n\t          do parent = new Array(4), parent[i] = node, node = parent;\n\t          while (z *= 2, x1 = x0 + z, y0 = y1 - z, x > x1 || y0 > y);\n\t          break;\n\t        }\n\t        case 3: {\n\t          do parent = new Array(4), parent[i] = node, node = parent;\n\t          while (z *= 2, x0 = x1 - z, y0 = y1 - z, x0 > x || y0 > y);\n\t          break;\n\t        }\n\t      }\n\t\n\t      if (this._root && this._root.length) this._root = node;\n\t    }\n\t\n\t    // If the quadtree covers the point already, just return.\n\t    else return this;\n\t\n\t    this._x0 = x0;\n\t    this._y0 = y0;\n\t    this._x1 = x1;\n\t    this._y1 = y1;\n\t    return this;\n\t  }\n\t\n\t  function tree_data() {\n\t    var data = [];\n\t    this.visit(function(node) {\n\t      if (!node.length) do data.push(node.data); while (node = node.next)\n\t    });\n\t    return data;\n\t  }\n\t\n\t  function tree_extent(_) {\n\t    return arguments.length\n\t        ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])\n\t        : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];\n\t  }\n\t\n\t  function Quad(node, x0, y0, x1, y1) {\n\t    this.node = node;\n\t    this.x0 = x0;\n\t    this.y0 = y0;\n\t    this.x1 = x1;\n\t    this.y1 = y1;\n\t  }\n\t\n\t  function tree_find(x, y, radius) {\n\t    var data,\n\t        x0 = this._x0,\n\t        y0 = this._y0,\n\t        x1,\n\t        y1,\n\t        x2,\n\t        y2,\n\t        x3 = this._x1,\n\t        y3 = this._y1,\n\t        quads = [],\n\t        node = this._root,\n\t        q,\n\t        i;\n\t\n\t    if (node) quads.push(new Quad(node, x0, y0, x3, y3));\n\t    if (radius == null) radius = Infinity;\n\t    else {\n\t      x0 = x - radius, y0 = y - radius;\n\t      x3 = x + radius, y3 = y + radius;\n\t      radius *= radius;\n\t    }\n\t\n\t    while (q = quads.pop()) {\n\t\n\t      // Stop searching if this quadrant cant contain a closer node.\n\t      if (!(node = q.node)\n\t          || (x1 = q.x0) > x3\n\t          || (y1 = q.y0) > y3\n\t          || (x2 = q.x1) < x0\n\t          || (y2 = q.y1) < y0) continue;\n\t\n\t      // Bisect the current quadrant.\n\t      if (node.length) {\n\t        var xm = (x1 + x2) / 2,\n\t            ym = (y1 + y2) / 2;\n\t\n\t        quads.push(\n\t          new Quad(node[3], xm, ym, x2, y2),\n\t          new Quad(node[2], x1, ym, xm, y2),\n\t          new Quad(node[1], xm, y1, x2, ym),\n\t          new Quad(node[0], x1, y1, xm, ym)\n\t        );\n\t\n\t        // Visit the closest quadrant first.\n\t        if (i = (y >= ym) << 1 | (x >= xm)) {\n\t          q = quads[quads.length - 1];\n\t          quads[quads.length - 1] = quads[quads.length - 1 - i];\n\t          quads[quads.length - 1 - i] = q;\n\t        }\n\t      }\n\t\n\t      // Visit this point. (Visiting coincident points isnt necessary!)\n\t      else {\n\t        var dx = x - +this._x.call(null, node.data),\n\t            dy = y - +this._y.call(null, node.data),\n\t            d2 = dx * dx + dy * dy;\n\t        if (d2 < radius) {\n\t          var d = Math.sqrt(radius = d2);\n\t          x0 = x - d, y0 = y - d;\n\t          x3 = x + d, y3 = y + d;\n\t          data = node.data;\n\t        }\n\t      }\n\t    }\n\t\n\t    return data;\n\t  }\n\t\n\t  function tree_remove(d) {\n\t    if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points\n\t\n\t    var parent,\n\t        node = this._root,\n\t        retainer,\n\t        previous,\n\t        next,\n\t        x0 = this._x0,\n\t        y0 = this._y0,\n\t        x1 = this._x1,\n\t        y1 = this._y1,\n\t        x,\n\t        y,\n\t        xm,\n\t        ym,\n\t        right,\n\t        bottom,\n\t        i,\n\t        j;\n\t\n\t    // If the tree is empty, initialize the root as a leaf.\n\t    if (!node) return this;\n\t\n\t    // Find the leaf node for the point.\n\t    // While descending, also retain the deepest parent with a non-removed sibling.\n\t    if (node.length) while (true) {\n\t      if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;\n\t      if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;\n\t      if (!(parent = node, node = node[i = bottom << 1 | right])) return this;\n\t      if (!node.length) break;\n\t      if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;\n\t    }\n\t\n\t    // Find the point to remove.\n\t    while (node.data !== d) if (!(previous = node, node = node.next)) return this;\n\t    if (next = node.next) delete node.next;\n\t\n\t    // If there are multiple coincident points, remove just the point.\n\t    if (previous) return (next ? previous.next = next : delete previous.next), this;\n\t\n\t    // If this is the root point, remove it.\n\t    if (!parent) return this._root = next, this;\n\t\n\t    // Remove this leaf.\n\t    next ? parent[i] = next : delete parent[i];\n\t\n\t    // If the parent now contains exactly one leaf, collapse superfluous parents.\n\t    if ((node = parent[0] || parent[1] || parent[2] || parent[3])\n\t        && node === (parent[3] || parent[2] || parent[1] || parent[0])\n\t        && !node.length) {\n\t      if (retainer) retainer[j] = node;\n\t      else this._root = node;\n\t    }\n\t\n\t    return this;\n\t  }\n\t\n\t  function removeAll(data) {\n\t    for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);\n\t    return this;\n\t  }\n\t\n\t  function tree_root() {\n\t    return this._root;\n\t  }\n\t\n\t  function tree_size() {\n\t    var size = 0;\n\t    this.visit(function(node) {\n\t      if (!node.length) do ++size; while (node = node.next)\n\t    });\n\t    return size;\n\t  }\n\t\n\t  function tree_visit(callback) {\n\t    var quads = [], q, node = this._root, child, x0, y0, x1, y1;\n\t    if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));\n\t    while (q = quads.pop()) {\n\t      if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {\n\t        var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;\n\t        if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));\n\t        if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));\n\t        if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));\n\t        if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));\n\t      }\n\t    }\n\t    return this;\n\t  }\n\t\n\t  function tree_visitAfter(callback) {\n\t    var quads = [], next = [], q;\n\t    if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));\n\t    while (q = quads.pop()) {\n\t      var node = q.node;\n\t      if (node.length) {\n\t        var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;\n\t        if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));\n\t        if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));\n\t        if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));\n\t        if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));\n\t      }\n\t      next.push(q);\n\t    }\n\t    while (q = next.pop()) {\n\t      callback(q.node, q.x0, q.y0, q.x1, q.y1);\n\t    }\n\t    return this;\n\t  }\n\t\n\t  function defaultX(d) {\n\t    return d[0];\n\t  }\n\t\n\t  function tree_x(_) {\n\t    return arguments.length ? (this._x = _, this) : this._x;\n\t  }\n\t\n\t  function defaultY(d) {\n\t    return d[1];\n\t  }\n\t\n\t  function tree_y(_) {\n\t    return arguments.length ? (this._y = _, this) : this._y;\n\t  }\n\t\n\t  function quadtree(nodes, x, y) {\n\t    var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);\n\t    return nodes == null ? tree : tree.addAll(nodes);\n\t  }\n\t\n\t  function Quadtree(x, y, x0, y0, x1, y1) {\n\t    this._x = x;\n\t    this._y = y;\n\t    this._x0 = x0;\n\t    this._y0 = y0;\n\t    this._x1 = x1;\n\t    this._y1 = y1;\n\t    this._root = undefined;\n\t  }\n\t\n\t  function leaf_copy(leaf) {\n\t    var copy = {data: leaf.data}, next = copy;\n\t    while (leaf = leaf.next) next = next.next = {data: leaf.data};\n\t    return copy;\n\t  }\n\t\n\t  var treeProto = quadtree.prototype = Quadtree.prototype;\n\t\n\t  treeProto.copy = function() {\n\t    var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),\n\t        node = this._root,\n\t        nodes,\n\t        child;\n\t\n\t    if (!node) return copy;\n\t\n\t    if (!node.length) return copy._root = leaf_copy(node), copy;\n\t\n\t    nodes = [{source: node, target: copy._root = new Array(4)}];\n\t    while (node = nodes.pop()) {\n\t      for (var i = 0; i < 4; ++i) {\n\t        if (child = node.source[i]) {\n\t          if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});\n\t          else node.target[i] = leaf_copy(child);\n\t        }\n\t      }\n\t    }\n\t\n\t    return copy;\n\t  };\n\t\n\t  treeProto.add = tree_add;\n\t  treeProto.addAll = addAll;\n\t  treeProto.cover = tree_cover;\n\t  treeProto.data = tree_data;\n\t  treeProto.extent = tree_extent;\n\t  treeProto.find = tree_find;\n\t  treeProto.remove = tree_remove;\n\t  treeProto.removeAll = removeAll;\n\t  treeProto.root = tree_root;\n\t  treeProto.size = tree_size;\n\t  treeProto.visit = tree_visit;\n\t  treeProto.visitAfter = tree_visitAfter;\n\t  treeProto.x = tree_x;\n\t  treeProto.y = tree_y;\n\t\n\t  exports.quadtree = quadtree;\n\t\n\t  Object.defineProperty(exports, '__esModule', { value: true });\n\t\n\t}));\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// https://d3js.org/d3-collection/ Version 1.0.1. Copyright 2016 Mike Bostock.\n\t(function (global, factory) {\n\t   true ? factory(exports) :\n\t  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t  (factory((global.d3 = global.d3 || {})));\n\t}(this, function (exports) { 'use strict';\n\t\n\t  var prefix = \"$\";\n\t\n\t  function Map() {}\n\t\n\t  Map.prototype = map.prototype = {\n\t    constructor: Map,\n\t    has: function(key) {\n\t      return (prefix + key) in this;\n\t    },\n\t    get: function(key) {\n\t      return this[prefix + key];\n\t    },\n\t    set: function(key, value) {\n\t      this[prefix + key] = value;\n\t      return this;\n\t    },\n\t    remove: function(key) {\n\t      var property = prefix + key;\n\t      return property in this && delete this[property];\n\t    },\n\t    clear: function() {\n\t      for (var property in this) if (property[0] === prefix) delete this[property];\n\t    },\n\t    keys: function() {\n\t      var keys = [];\n\t      for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));\n\t      return keys;\n\t    },\n\t    values: function() {\n\t      var values = [];\n\t      for (var property in this) if (property[0] === prefix) values.push(this[property]);\n\t      return values;\n\t    },\n\t    entries: function() {\n\t      var entries = [];\n\t      for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});\n\t      return entries;\n\t    },\n\t    size: function() {\n\t      var size = 0;\n\t      for (var property in this) if (property[0] === prefix) ++size;\n\t      return size;\n\t    },\n\t    empty: function() {\n\t      for (var property in this) if (property[0] === prefix) return false;\n\t      return true;\n\t    },\n\t    each: function(f) {\n\t      for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);\n\t    }\n\t  };\n\t\n\t  function map(object, f) {\n\t    var map = new Map;\n\t\n\t    // Copy constructor.\n\t    if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });\n\t\n\t    // Index array by numeric index or specified key function.\n\t    else if (Array.isArray(object)) {\n\t      var i = -1,\n\t          n = object.length,\n\t          o;\n\t\n\t      if (f == null) while (++i < n) map.set(i, object[i]);\n\t      else while (++i < n) map.set(f(o = object[i], i, object), o);\n\t    }\n\t\n\t    // Convert object to map.\n\t    else if (object) for (var key in object) map.set(key, object[key]);\n\t\n\t    return map;\n\t  }\n\t\n\t  function nest() {\n\t    var keys = [],\n\t        sortKeys = [],\n\t        sortValues,\n\t        rollup,\n\t        nest;\n\t\n\t    function apply(array, depth, createResult, setResult) {\n\t      if (depth >= keys.length) return rollup != null\n\t          ? rollup(array) : (sortValues != null\n\t          ? array.sort(sortValues)\n\t          : array);\n\t\n\t      var i = -1,\n\t          n = array.length,\n\t          key = keys[depth++],\n\t          keyValue,\n\t          value,\n\t          valuesByKey = map(),\n\t          values,\n\t          result = createResult();\n\t\n\t      while (++i < n) {\n\t        if (values = valuesByKey.get(keyValue = key(value = array[i]) + \"\")) {\n\t          values.push(value);\n\t        } else {\n\t          valuesByKey.set(keyValue, [value]);\n\t        }\n\t      }\n\t\n\t      valuesByKey.each(function(values, key) {\n\t        setResult(result, key, apply(values, depth, createResult, setResult));\n\t      });\n\t\n\t      return result;\n\t    }\n\t\n\t    function entries(map, depth) {\n\t      if (++depth > keys.length) return map;\n\t      var array, sortKey = sortKeys[depth - 1];\n\t      if (rollup != null && depth >= keys.length) array = map.entries();\n\t      else array = [], map.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });\n\t      return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;\n\t    }\n\t\n\t    return nest = {\n\t      object: function(array) { return apply(array, 0, createObject, setObject); },\n\t      map: function(array) { return apply(array, 0, createMap, setMap); },\n\t      entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },\n\t      key: function(d) { keys.push(d); return nest; },\n\t      sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },\n\t      sortValues: function(order) { sortValues = order; return nest; },\n\t      rollup: function(f) { rollup = f; return nest; }\n\t    };\n\t  }\n\t\n\t  function createObject() {\n\t    return {};\n\t  }\n\t\n\t  function setObject(object, key, value) {\n\t    object[key] = value;\n\t  }\n\t\n\t  function createMap() {\n\t    return map();\n\t  }\n\t\n\t  function setMap(map, key, value) {\n\t    map.set(key, value);\n\t  }\n\t\n\t  function Set() {}\n\t\n\t  var proto = map.prototype;\n\t\n\t  Set.prototype = set.prototype = {\n\t    constructor: Set,\n\t    has: proto.has,\n\t    add: function(value) {\n\t      value += \"\";\n\t      this[prefix + value] = value;\n\t      return this;\n\t    },\n\t    remove: proto.remove,\n\t    clear: proto.clear,\n\t    values: proto.keys,\n\t    size: proto.size,\n\t    empty: proto.empty,\n\t    each: proto.each\n\t  };\n\t\n\t  function set(object, f) {\n\t    var set = new Set;\n\t\n\t    // Copy constructor.\n\t    if (object instanceof Set) object.each(function(value) { set.add(value); });\n\t\n\t    // Otherwise, assume its an array.\n\t    else if (object) {\n\t      var i = -1, n = object.length;\n\t      if (f == null) while (++i < n) set.add(object[i]);\n\t      else while (++i < n) set.add(f(object[i], i, object));\n\t    }\n\t\n\t    return set;\n\t  }\n\t\n\t  function keys(map) {\n\t    var keys = [];\n\t    for (var key in map) keys.push(key);\n\t    return keys;\n\t  }\n\t\n\t  function values(map) {\n\t    var values = [];\n\t    for (var key in map) values.push(map[key]);\n\t    return values;\n\t  }\n\t\n\t  function entries(map) {\n\t    var entries = [];\n\t    for (var key in map) entries.push({key: key, value: map[key]});\n\t    return entries;\n\t  }\n\t\n\t  exports.nest = nest;\n\t  exports.set = set;\n\t  exports.map = map;\n\t  exports.keys = keys;\n\t  exports.values = values;\n\t  exports.entries = entries;\n\t\n\t  Object.defineProperty(exports, '__esModule', { value: true });\n\t\n\t}));\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// https://d3js.org/d3-dispatch/ Version 1.0.1. Copyright 2016 Mike Bostock.\n\t(function (global, factory) {\n\t   true ? factory(exports) :\n\t  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t  (factory((global.d3 = global.d3 || {})));\n\t}(this, function (exports) { 'use strict';\n\t\n\t  var noop = {value: function() {}};\n\t\n\t  function dispatch() {\n\t    for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {\n\t      if (!(t = arguments[i] + \"\") || (t in _)) throw new Error(\"illegal type: \" + t);\n\t      _[t] = [];\n\t    }\n\t    return new Dispatch(_);\n\t  }\n\t\n\t  function Dispatch(_) {\n\t    this._ = _;\n\t  }\n\t\n\t  function parseTypenames(typenames, types) {\n\t    return typenames.trim().split(/^|\\s+/).map(function(t) {\n\t      var name = \"\", i = t.indexOf(\".\");\n\t      if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);\n\t      if (t && !types.hasOwnProperty(t)) throw new Error(\"unknown type: \" + t);\n\t      return {type: t, name: name};\n\t    });\n\t  }\n\t\n\t  Dispatch.prototype = dispatch.prototype = {\n\t    constructor: Dispatch,\n\t    on: function(typename, callback) {\n\t      var _ = this._,\n\t          T = parseTypenames(typename + \"\", _),\n\t          t,\n\t          i = -1,\n\t          n = T.length;\n\t\n\t      // If no callback was specified, return the callback of the given type and name.\n\t      if (arguments.length < 2) {\n\t        while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;\n\t        return;\n\t      }\n\t\n\t      // If a type was specified, set the callback for the given type and name.\n\t      // Otherwise, if a null callback was specified, remove callbacks of the given name.\n\t      if (callback != null && typeof callback !== \"function\") throw new Error(\"invalid callback: \" + callback);\n\t      while (++i < n) {\n\t        if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);\n\t        else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);\n\t      }\n\t\n\t      return this;\n\t    },\n\t    copy: function() {\n\t      var copy = {}, _ = this._;\n\t      for (var t in _) copy[t] = _[t].slice();\n\t      return new Dispatch(copy);\n\t    },\n\t    call: function(type, that) {\n\t      if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];\n\t      if (!this._.hasOwnProperty(type)) throw new Error(\"unknown type: \" + type);\n\t      for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);\n\t    },\n\t    apply: function(type, that, args) {\n\t      if (!this._.hasOwnProperty(type)) throw new Error(\"unknown type: \" + type);\n\t      for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);\n\t    }\n\t  };\n\t\n\t  function get(type, name) {\n\t    for (var i = 0, n = type.length, c; i < n; ++i) {\n\t      if ((c = type[i]).name === name) {\n\t        return c.value;\n\t      }\n\t    }\n\t  }\n\t\n\t  function set(type, name, callback) {\n\t    for (var i = 0, n = type.length; i < n; ++i) {\n\t      if (type[i].name === name) {\n\t        type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));\n\t        break;\n\t      }\n\t    }\n\t    if (callback != null) type.push({name: name, value: callback});\n\t    return type;\n\t  }\n\t\n\t  exports.dispatch = dispatch;\n\t\n\t  Object.defineProperty(exports, '__esModule', { value: true });\n\t\n\t}));\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// https://d3js.org/d3-timer/ Version 1.0.2. Copyright 2016 Mike Bostock.\n\t(function (global, factory) {\n\t   true ? factory(exports) :\n\t  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t  (factory((global.d3 = global.d3 || {})));\n\t}(this, function (exports) { 'use strict';\n\t\n\t  var frame = 0;\n\t  var timeout = 0;\n\t  var interval = 0;\n\t  var pokeDelay = 1000;\n\t  var taskHead;\n\t  var taskTail;\n\t  var clockLast = 0;\n\t  var clockNow = 0;\n\t  var clockSkew = 0;\n\t  var clock = typeof performance === \"object\" && performance.now ? performance : Date;\n\t  var setFrame = typeof requestAnimationFrame === \"function\"\n\t          ? (clock === Date ? function(f) { requestAnimationFrame(function() { f(clock.now()); }); } : requestAnimationFrame)\n\t          : function(f) { setTimeout(f, 17); };\n\t  function now() {\n\t    return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);\n\t  }\n\t\n\t  function clearNow() {\n\t    clockNow = 0;\n\t  }\n\t\n\t  function Timer() {\n\t    this._call =\n\t    this._time =\n\t    this._next = null;\n\t  }\n\t\n\t  Timer.prototype = timer.prototype = {\n\t    constructor: Timer,\n\t    restart: function(callback, delay, time) {\n\t      if (typeof callback !== \"function\") throw new TypeError(\"callback is not a function\");\n\t      time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);\n\t      if (!this._next && taskTail !== this) {\n\t        if (taskTail) taskTail._next = this;\n\t        else taskHead = this;\n\t        taskTail = this;\n\t      }\n\t      this._call = callback;\n\t      this._time = time;\n\t      sleep();\n\t    },\n\t    stop: function() {\n\t      if (this._call) {\n\t        this._call = null;\n\t        this._time = Infinity;\n\t        sleep();\n\t      }\n\t    }\n\t  };\n\t\n\t  function timer(callback, delay, time) {\n\t    var t = new Timer;\n\t    t.restart(callback, delay, time);\n\t    return t;\n\t  }\n\t\n\t  function timerFlush() {\n\t    now(); // Get the current time, if not already set.\n\t    ++frame; // Pretend weve set an alarm, if we havent already.\n\t    var t = taskHead, e;\n\t    while (t) {\n\t      if ((e = clockNow - t._time) >= 0) t._call.call(null, e);\n\t      t = t._next;\n\t    }\n\t    --frame;\n\t  }\n\t\n\t  function wake(time) {\n\t    clockNow = (clockLast = time || clock.now()) + clockSkew;\n\t    frame = timeout = 0;\n\t    try {\n\t      timerFlush();\n\t    } finally {\n\t      frame = 0;\n\t      nap();\n\t      clockNow = 0;\n\t    }\n\t  }\n\t\n\t  function poke() {\n\t    var now = clock.now(), delay = now - clockLast;\n\t    if (delay > pokeDelay) clockSkew -= delay, clockLast = now;\n\t  }\n\t\n\t  function nap() {\n\t    var t0, t1 = taskHead, t2, time = Infinity;\n\t    while (t1) {\n\t      if (t1._call) {\n\t        if (time > t1._time) time = t1._time;\n\t        t0 = t1, t1 = t1._next;\n\t      } else {\n\t        t2 = t1._next, t1._next = null;\n\t        t1 = t0 ? t0._next = t2 : taskHead = t2;\n\t      }\n\t    }\n\t    taskTail = t0;\n\t    sleep(time);\n\t  }\n\t\n\t  function sleep(time) {\n\t    if (frame) return; // Soonest alarm already set, or will be.\n\t    if (timeout) timeout = clearTimeout(timeout);\n\t    var delay = time - clockNow;\n\t    if (delay > 24) {\n\t      if (time < Infinity) timeout = setTimeout(wake, delay);\n\t      if (interval) interval = clearInterval(interval);\n\t    } else {\n\t      if (!interval) interval = setInterval(poke, pokeDelay);\n\t      frame = 1, setFrame(wake);\n\t    }\n\t  }\n\t\n\t  function timeout$1(callback, delay, time) {\n\t    var t = new Timer;\n\t    delay = delay == null ? 0 : +delay;\n\t    t.restart(function(elapsed) {\n\t      t.stop();\n\t      callback(elapsed + delay);\n\t    }, delay, time);\n\t    return t;\n\t  }\n\t\n\t  function interval$1(callback, delay, time) {\n\t    var t = new Timer, total = delay;\n\t    if (delay == null) return t.restart(callback, delay, time), t;\n\t    delay = +delay, time = time == null ? now() : +time;\n\t    t.restart(function tick(elapsed) {\n\t      elapsed += total;\n\t      t.restart(tick, total += delay, time);\n\t      callback(elapsed);\n\t    }, delay, time);\n\t    return t;\n\t  }\n\t\n\t  exports.now = now;\n\t  exports.timer = timer;\n\t  exports.timerFlush = timerFlush;\n\t  exports.timeout = timeout$1;\n\t  exports.interval = interval$1;\n\t\n\t  Object.defineProperty(exports, '__esModule', { value: true });\n\t\n\t}));\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"nodes\": [\n\t\t\t{\n\t\t\t\t\"id\": \"A\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"id\": \"B\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"id\": \"C\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"id\": \"D\"\n\t\t\t}\n\t\t],\n\t\t\"links\": [\n\t\t\t{\n\t\t\t\t\"source\": \"A\",\n\t\t\t\t\"target\": \"B\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"source\": \"A\",\n\t\t\t\t\"target\": \"C\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"source\": \"A\",\n\t\t\t\t\"target\": \"D\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"source\": \"B\",\n\t\t\t\t\"target\": \"D\"\n\t\t\t}\n\t\t]\n\t};\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** brambl.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 9849ad196c00bd70d8c0\n **/","// Main export\nmodule.exports = {\n  Graph: require('./js/brambl.graph.js')\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/bundle.js\n **/","var d3    = require('d3-force');\nvar data = require('./data.json');\n\nclass Graph {\n\n  /* Create an instance of a brambl \n   *\n   */\n  constructor(selector, options) {\n    this.selector  = selector;\n    this.options   = options || {};\n    this.container = document.querySelector(selector);\n  }\n\n  // Lots of horrible side effects in here at the moment - this is just\n  // because the code here is largely a copy/paste job from a d3 example\n  // and this whole thing is basically just in \"bootstrapping mode\" at the \n  // moment while I get the env set up the way I want it. \n  //\n  // Don't judge me!!\n  //\n  start() {\n\n    var canvas = document.createElement('canvas');\n    container.appendChild(canvas);\n\n    var context = canvas.getContext(\"2d\");\n\n    var width = canvas.width = 1000;\n    var height = canvas.height = 500;\n\n    var simulation = d3.forceSimulation()\n        .force(\"link\", d3.forceLink().id(d => d.id))\n        .force(\"charge\", d3.forceManyBody())\n        .force(\"center\", d3.forceCenter(width / 2, height / 2));\n\n    simulation\n        .nodes(data.nodes)\n        .on(\"tick\", redraw);\n\n    simulation.force(\"link\")\n        .links(data.links)\n        .distance(d =>  100);\n\n    function redraw() {\n      context.clearRect(0, 0, width, height);\n\n      context.beginPath();\n      data.links.forEach(drawLink);\n      context.stroke();\n\n      context.beginPath();\n      data.nodes.forEach(drawNode);\n      context.fill();\n    }\n\n    function drawLink(d) {\n      context.moveTo(d.source.x, d.source.y);\n      context.lineTo(d.target.x, d.target.y);\n    }\n\n    function drawNode(d) {\n      context.moveTo(d.x + 3, d.y);\n      context.arc(d.x, d.y, 20, 0, 2 * Math.PI);\n    }\n\n  }\n  \n}\n\nmodule.exports = Graph; \n\n\n\n/** WEBPACK FOOTER **\n ** ./src/js/brambl.graph.js\n **/","// https://d3js.org/d3-force/ Version 1.0.2. Copyright 2016 Mike Bostock.\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-quadtree'), require('d3-collection'), require('d3-dispatch'), require('d3-timer')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'd3-quadtree', 'd3-collection', 'd3-dispatch', 'd3-timer'], factory) :\n  (factory((global.d3 = global.d3 || {}),global.d3,global.d3,global.d3,global.d3));\n}(this, function (exports,d3Quadtree,d3Collection,d3Dispatch,d3Timer) { 'use strict';\n\n  function center(x, y) {\n    var nodes;\n\n    if (x == null) x = 0;\n    if (y == null) y = 0;\n\n    function force() {\n      var i,\n          n = nodes.length,\n          node,\n          sx = 0,\n          sy = 0;\n\n      for (i = 0; i < n; ++i) {\n        node = nodes[i], sx += node.x, sy += node.y;\n      }\n\n      for (sx = sx / n - x, sy = sy / n - y, i = 0; i < n; ++i) {\n        node = nodes[i], node.x -= sx, node.y -= sy;\n      }\n    }\n\n    force.initialize = function(_) {\n      nodes = _;\n    };\n\n    force.x = function(_) {\n      return arguments.length ? (x = +_, force) : x;\n    };\n\n    force.y = function(_) {\n      return arguments.length ? (y = +_, force) : y;\n    };\n\n    return force;\n  }\n\n  function constant(x) {\n    return function() {\n      return x;\n    };\n  }\n\n  function jiggle() {\n    return (Math.random() - 0.5) * 1e-6;\n  }\n\n  function x(d) {\n    return d.x + d.vx;\n  }\n\n  function y(d) {\n    return d.y + d.vy;\n  }\n\n  function collide(radius) {\n    var nodes,\n        radii,\n        strength = 1,\n        iterations = 1;\n\n    if (typeof radius !== \"function\") radius = constant(radius == null ? 1 : +radius);\n\n    function force() {\n      var i, n = nodes.length,\n          tree,\n          node,\n          xi,\n          yi,\n          ri,\n          ri2;\n\n      for (var k = 0; k < iterations; ++k) {\n        tree = d3Quadtree.quadtree(nodes, x, y).visitAfter(prepare);\n        for (i = 0; i < n; ++i) {\n          node = nodes[i];\n          ri = radii[i], ri2 = ri * ri;\n          xi = node.x + node.vx;\n          yi = node.y + node.vy;\n          tree.visit(apply);\n        }\n      }\n\n      function apply(quad, x0, y0, x1, y1) {\n        var data = quad.data, rj = quad.r, r = ri + rj;\n        if (data) {\n          if (data.index > i) {\n            var x = xi - data.x - data.vx,\n                y = yi - data.y - data.vy,\n                l = x * x + y * y;\n            if (l < r * r) {\n              if (x === 0) x = jiggle(), l += x * x;\n              if (y === 0) y = jiggle(), l += y * y;\n              l = (r - (l = Math.sqrt(l))) / l * strength;\n              node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));\n              node.vy += (y *= l) * r;\n              data.vx -= x * (r = 1 - r);\n              data.vy -= y * r;\n            }\n          }\n          return;\n        }\n        return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;\n      }\n    }\n\n    function prepare(quad) {\n      if (quad.data) return quad.r = radii[quad.data.index];\n      for (var i = quad.r = 0; i < 4; ++i) {\n        if (quad[i] && quad[i].r > quad.r) {\n          quad.r = quad[i].r;\n        }\n      }\n    }\n\n    force.initialize = function(_) {\n      var i, n = (nodes = _).length; radii = new Array(n);\n      for (i = 0; i < n; ++i) radii[i] = +radius(nodes[i], i, nodes);\n    };\n\n    force.iterations = function(_) {\n      return arguments.length ? (iterations = +_, force) : iterations;\n    };\n\n    force.strength = function(_) {\n      return arguments.length ? (strength = +_, force) : strength;\n    };\n\n    force.radius = function(_) {\n      return arguments.length ? (radius = typeof _ === \"function\" ? _ : constant(+_), force) : radius;\n    };\n\n    return force;\n  }\n\n  function index(d, i) {\n    return i;\n  }\n\n  function link(links) {\n    var id = index,\n        strength = defaultStrength,\n        strengths,\n        distance = constant(30),\n        distances,\n        nodes,\n        count,\n        bias,\n        iterations = 1;\n\n    if (links == null) links = [];\n\n    function defaultStrength(link) {\n      return 1 / Math.min(count[link.source.index], count[link.target.index]);\n    }\n\n    function force(alpha) {\n      for (var k = 0, n = links.length; k < iterations; ++k) {\n        for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {\n          link = links[i], source = link.source, target = link.target;\n          x = target.x + target.vx - source.x - source.vx || jiggle();\n          y = target.y + target.vy - source.y - source.vy || jiggle();\n          l = Math.sqrt(x * x + y * y);\n          l = (l - distances[i]) / l * alpha * strengths[i];\n          x *= l, y *= l;\n          target.vx -= x * (b = bias[i]);\n          target.vy -= y * b;\n          source.vx += x * (b = 1 - b);\n          source.vy += y * b;\n        }\n      }\n    }\n\n    function initialize() {\n      if (!nodes) return;\n\n      var i,\n          n = nodes.length,\n          m = links.length,\n          nodeById = d3Collection.map(nodes, id),\n          link;\n\n      for (i = 0, count = new Array(n); i < n; ++i) {\n        count[i] = 0;\n      }\n\n      for (i = 0; i < m; ++i) {\n        link = links[i], link.index = i;\n        if (typeof link.source !== \"object\") link.source = nodeById.get(link.source);\n        if (typeof link.target !== \"object\") link.target = nodeById.get(link.target);\n        ++count[link.source.index], ++count[link.target.index];\n      }\n\n      for (i = 0, bias = new Array(m); i < m; ++i) {\n        link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);\n      }\n\n      strengths = new Array(m), initializeStrength();\n      distances = new Array(m), initializeDistance();\n    }\n\n    function initializeStrength() {\n      if (!nodes) return;\n\n      for (var i = 0, n = links.length; i < n; ++i) {\n        strengths[i] = +strength(links[i], i, links);\n      }\n    }\n\n    function initializeDistance() {\n      if (!nodes) return;\n\n      for (var i = 0, n = links.length; i < n; ++i) {\n        distances[i] = +distance(links[i], i, links);\n      }\n    }\n\n    force.initialize = function(_) {\n      nodes = _;\n      initialize();\n    };\n\n    force.links = function(_) {\n      return arguments.length ? (links = _, initialize(), force) : links;\n    };\n\n    force.id = function(_) {\n      return arguments.length ? (id = _, force) : id;\n    };\n\n    force.iterations = function(_) {\n      return arguments.length ? (iterations = +_, force) : iterations;\n    };\n\n    force.strength = function(_) {\n      return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant(+_), initializeStrength(), force) : strength;\n    };\n\n    force.distance = function(_) {\n      return arguments.length ? (distance = typeof _ === \"function\" ? _ : constant(+_), initializeDistance(), force) : distance;\n    };\n\n    return force;\n  }\n\n  function x$1(d) {\n    return d.x;\n  }\n\n  function y$1(d) {\n    return d.y;\n  }\n\n  var initialRadius = 10;\n  var initialAngle = Math.PI * (3 - Math.sqrt(5));\n  function simulation(nodes) {\n    var simulation,\n        alpha = 1,\n        alphaMin = 0.001,\n        alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),\n        alphaTarget = 0,\n        velocityDecay = 0.6,\n        forces = d3Collection.map(),\n        stepper = d3Timer.timer(step),\n        event = d3Dispatch.dispatch(\"tick\", \"end\");\n\n    if (nodes == null) nodes = [];\n\n    function step() {\n      tick();\n      event.call(\"tick\", simulation);\n      if (alpha < alphaMin) {\n        stepper.stop();\n        event.call(\"end\", simulation);\n      }\n    }\n\n    function tick() {\n      var i, n = nodes.length, node;\n\n      alpha += (alphaTarget - alpha) * alphaDecay;\n\n      forces.each(function(force) {\n        force(alpha);\n      });\n\n      for (i = 0; i < n; ++i) {\n        node = nodes[i];\n        if (node.fx == null) node.x += node.vx *= velocityDecay;\n        else node.x = node.fx, node.vx = 0;\n        if (node.fy == null) node.y += node.vy *= velocityDecay;\n        else node.y = node.fy, node.vy = 0;\n      }\n    }\n\n    function initializeNodes() {\n      for (var i = 0, n = nodes.length, node; i < n; ++i) {\n        node = nodes[i], node.index = i;\n        if (isNaN(node.x) || isNaN(node.y)) {\n          var radius = initialRadius * Math.sqrt(i), angle = i * initialAngle;\n          node.x = radius * Math.cos(angle);\n          node.y = radius * Math.sin(angle);\n        }\n        if (isNaN(node.vx) || isNaN(node.vy)) {\n          node.vx = node.vy = 0;\n        }\n      }\n    }\n\n    function initializeForce(force) {\n      if (force.initialize) force.initialize(nodes);\n      return force;\n    }\n\n    initializeNodes();\n\n    return simulation = {\n      tick: tick,\n\n      restart: function() {\n        return stepper.restart(step), simulation;\n      },\n\n      stop: function() {\n        return stepper.stop(), simulation;\n      },\n\n      nodes: function(_) {\n        return arguments.length ? (nodes = _, initializeNodes(), forces.each(initializeForce), simulation) : nodes;\n      },\n\n      alpha: function(_) {\n        return arguments.length ? (alpha = +_, simulation) : alpha;\n      },\n\n      alphaMin: function(_) {\n        return arguments.length ? (alphaMin = +_, simulation) : alphaMin;\n      },\n\n      alphaDecay: function(_) {\n        return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;\n      },\n\n      alphaTarget: function(_) {\n        return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;\n      },\n\n      velocityDecay: function(_) {\n        return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;\n      },\n\n      force: function(name, _) {\n        return arguments.length > 1 ? ((_ == null ? forces.remove(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);\n      },\n\n      find: function(x, y, radius) {\n        var i = 0,\n            n = nodes.length,\n            dx,\n            dy,\n            d2,\n            node,\n            closest;\n\n        if (radius == null) radius = Infinity;\n        else radius *= radius;\n\n        for (i = 0; i < n; ++i) {\n          node = nodes[i];\n          dx = x - node.x;\n          dy = y - node.y;\n          d2 = dx * dx + dy * dy;\n          if (d2 < radius) closest = node, radius = d2;\n        }\n\n        return closest;\n      },\n\n      on: function(name, _) {\n        return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);\n      }\n    };\n  }\n\n  function manyBody() {\n    var nodes,\n        node,\n        alpha,\n        strength = constant(-30),\n        strengths,\n        distanceMin2 = 1,\n        distanceMax2 = Infinity,\n        theta2 = 0.81;\n\n    function force(_) {\n      var i, n = nodes.length, tree = d3Quadtree.quadtree(nodes, x$1, y$1).visitAfter(accumulate);\n      for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);\n    }\n\n    function initialize() {\n      if (!nodes) return;\n      var i, n = nodes.length;\n      strengths = new Array(n);\n      for (i = 0; i < n; ++i) strengths[i] = +strength(nodes[i], i, nodes);\n    }\n\n    function accumulate(quad) {\n      var strength = 0, q, c, x, y, i;\n\n      // For internal nodes, accumulate forces from child quadrants.\n      if (quad.length) {\n        for (x = y = i = 0; i < 4; ++i) {\n          if ((q = quad[i]) && (c = q.value)) {\n            strength += c, x += c * q.x, y += c * q.y;\n          }\n        }\n        quad.x = x / strength;\n        quad.y = y / strength;\n      }\n\n      // For leaf nodes, accumulate forces from coincident quadrants.\n      else {\n        q = quad;\n        q.x = q.data.x;\n        q.y = q.data.y;\n        do strength += strengths[q.data.index];\n        while (q = q.next);\n      }\n\n      quad.value = strength;\n    }\n\n    function apply(quad, x1, _, x2) {\n      if (!quad.value) return true;\n\n      var x = quad.x - node.x,\n          y = quad.y - node.y,\n          w = x2 - x1,\n          l = x * x + y * y;\n\n      // Apply the Barnes-Hut approximation if possible.\n      // Limit forces for very close nodes; randomize direction if coincident.\n      if (w * w / theta2 < l) {\n        if (l < distanceMax2) {\n          if (x === 0) x = jiggle(), l += x * x;\n          if (y === 0) y = jiggle(), l += y * y;\n          if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);\n          node.vx += x * quad.value * alpha / l;\n          node.vy += y * quad.value * alpha / l;\n        }\n        return true;\n      }\n\n      // Otherwise, process points directly.\n      else if (quad.length || l >= distanceMax2) return;\n\n      // Limit forces for very close nodes; randomize direction if coincident.\n      if (quad.data !== node || quad.next) {\n        if (x === 0) x = jiggle(), l += x * x;\n        if (y === 0) y = jiggle(), l += y * y;\n        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);\n      }\n\n      do if (quad.data !== node) {\n        w = strengths[quad.data.index] * alpha / l;\n        node.vx += x * w;\n        node.vy += y * w;\n      } while (quad = quad.next);\n    }\n\n    force.initialize = function(_) {\n      nodes = _;\n      initialize();\n    };\n\n    force.strength = function(_) {\n      return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant(+_), initialize(), force) : strength;\n    };\n\n    force.distanceMin = function(_) {\n      return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);\n    };\n\n    force.distanceMax = function(_) {\n      return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);\n    };\n\n    force.theta = function(_) {\n      return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);\n    };\n\n    return force;\n  }\n\n  function x$2(x) {\n    var strength = constant(0.1),\n        nodes,\n        strengths,\n        xz;\n\n    if (typeof x !== \"function\") x = constant(x == null ? 0 : +x);\n\n    function force(alpha) {\n      for (var i = 0, n = nodes.length, node; i < n; ++i) {\n        node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;\n      }\n    }\n\n    function initialize() {\n      if (!nodes) return;\n      var i, n = nodes.length;\n      strengths = new Array(n);\n      xz = new Array(n);\n      for (i = 0; i < n; ++i) {\n        strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);\n      }\n    }\n\n    force.initialize = function(_) {\n      nodes = _;\n      initialize();\n    };\n\n    force.strength = function(_) {\n      return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant(+_), initialize(), force) : strength;\n    };\n\n    force.x = function(_) {\n      return arguments.length ? (x = typeof _ === \"function\" ? _ : constant(+_), initialize(), force) : x;\n    };\n\n    return force;\n  }\n\n  function y$2(y) {\n    var strength = constant(0.1),\n        nodes,\n        strengths,\n        yz;\n\n    if (typeof y !== \"function\") y = constant(y == null ? 0 : +y);\n\n    function force(alpha) {\n      for (var i = 0, n = nodes.length, node; i < n; ++i) {\n        node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;\n      }\n    }\n\n    function initialize() {\n      if (!nodes) return;\n      var i, n = nodes.length;\n      strengths = new Array(n);\n      yz = new Array(n);\n      for (i = 0; i < n; ++i) {\n        strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);\n      }\n    }\n\n    force.initialize = function(_) {\n      nodes = _;\n      initialize();\n    };\n\n    force.strength = function(_) {\n      return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant(+_), initialize(), force) : strength;\n    };\n\n    force.y = function(_) {\n      return arguments.length ? (y = typeof _ === \"function\" ? _ : constant(+_), initialize(), force) : y;\n    };\n\n    return force;\n  }\n\n  exports.forceCenter = center;\n  exports.forceCollide = collide;\n  exports.forceLink = link;\n  exports.forceManyBody = manyBody;\n  exports.forceSimulation = simulation;\n  exports.forceX = x$2;\n  exports.forceY = y$2;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/d3-force/build/d3-force.js\n ** module id = 2\n ** module chunks = 0\n **/","// https://d3js.org/d3-quadtree/ Version 1.0.1. Copyright 2016 Mike Bostock.\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.d3 = global.d3 || {})));\n}(this, function (exports) { 'use strict';\n\n  function tree_add(d) {\n    var x = +this._x.call(null, d),\n        y = +this._y.call(null, d);\n    return add(this.cover(x, y), x, y, d);\n  }\n\n  function add(tree, x, y, d) {\n    if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points\n\n    var parent,\n        node = tree._root,\n        leaf = {data: d},\n        x0 = tree._x0,\n        y0 = tree._y0,\n        x1 = tree._x1,\n        y1 = tree._y1,\n        xm,\n        ym,\n        xp,\n        yp,\n        right,\n        bottom,\n        i,\n        j;\n\n    // If the tree is empty, initialize the root as a leaf.\n    if (!node) return tree._root = leaf, tree;\n\n    // Find the existing leaf for the new point, or add it.\n    while (node.length) {\n      if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;\n      if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;\n      if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;\n    }\n\n    // Is the new point is exactly coincident with the existing point?\n    xp = +tree._x.call(null, node.data);\n    yp = +tree._y.call(null, node.data);\n    if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;\n\n    // Otherwise, split the leaf node until the old and new point are separated.\n    do {\n      parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);\n      if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;\n      if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;\n    } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));\n    return parent[j] = node, parent[i] = leaf, tree;\n  }\n\n  function addAll(data) {\n    var d, i, n = data.length,\n        x,\n        y,\n        xz = new Array(n),\n        yz = new Array(n),\n        x0 = Infinity,\n        y0 = Infinity,\n        x1 = -Infinity,\n        y1 = -Infinity;\n\n    // Compute the points and their extent.\n    for (i = 0; i < n; ++i) {\n      if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;\n      xz[i] = x;\n      yz[i] = y;\n      if (x < x0) x0 = x;\n      if (x > x1) x1 = x;\n      if (y < y0) y0 = y;\n      if (y > y1) y1 = y;\n    }\n\n    // If there were no (valid) points, inherit the existing extent.\n    if (x1 < x0) x0 = this._x0, x1 = this._x1;\n    if (y1 < y0) y0 = this._y0, y1 = this._y1;\n\n    // Expand the tree to cover the new points.\n    this.cover(x0, y0).cover(x1, y1);\n\n    // Add the new points.\n    for (i = 0; i < n; ++i) {\n      add(this, xz[i], yz[i], data[i]);\n    }\n\n    return this;\n  }\n\n  function tree_cover(x, y) {\n    if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points\n\n    var x0 = this._x0,\n        y0 = this._y0,\n        x1 = this._x1,\n        y1 = this._y1;\n\n    // If the quadtree has no extent, initialize them.\n    // Integer extent are necessary so that if we later double the extent,\n    // the existing quadrant boundaries dont change due to floating point error!\n    if (isNaN(x0)) {\n      x1 = (x0 = Math.floor(x)) + 1;\n      y1 = (y0 = Math.floor(y)) + 1;\n    }\n\n    // Otherwise, double repeatedly to cover.\n    else if (x0 > x || x > x1 || y0 > y || y > y1) {\n      var z = x1 - x0,\n          node = this._root,\n          parent,\n          i;\n\n      switch (i = (y < (y0 + y1) / 2) << 1 | (x < (x0 + x1) / 2)) {\n        case 0: {\n          do parent = new Array(4), parent[i] = node, node = parent;\n          while (z *= 2, x1 = x0 + z, y1 = y0 + z, x > x1 || y > y1);\n          break;\n        }\n        case 1: {\n          do parent = new Array(4), parent[i] = node, node = parent;\n          while (z *= 2, x0 = x1 - z, y1 = y0 + z, x0 > x || y > y1);\n          break;\n        }\n        case 2: {\n          do parent = new Array(4), parent[i] = node, node = parent;\n          while (z *= 2, x1 = x0 + z, y0 = y1 - z, x > x1 || y0 > y);\n          break;\n        }\n        case 3: {\n          do parent = new Array(4), parent[i] = node, node = parent;\n          while (z *= 2, x0 = x1 - z, y0 = y1 - z, x0 > x || y0 > y);\n          break;\n        }\n      }\n\n      if (this._root && this._root.length) this._root = node;\n    }\n\n    // If the quadtree covers the point already, just return.\n    else return this;\n\n    this._x0 = x0;\n    this._y0 = y0;\n    this._x1 = x1;\n    this._y1 = y1;\n    return this;\n  }\n\n  function tree_data() {\n    var data = [];\n    this.visit(function(node) {\n      if (!node.length) do data.push(node.data); while (node = node.next)\n    });\n    return data;\n  }\n\n  function tree_extent(_) {\n    return arguments.length\n        ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])\n        : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];\n  }\n\n  function Quad(node, x0, y0, x1, y1) {\n    this.node = node;\n    this.x0 = x0;\n    this.y0 = y0;\n    this.x1 = x1;\n    this.y1 = y1;\n  }\n\n  function tree_find(x, y, radius) {\n    var data,\n        x0 = this._x0,\n        y0 = this._y0,\n        x1,\n        y1,\n        x2,\n        y2,\n        x3 = this._x1,\n        y3 = this._y1,\n        quads = [],\n        node = this._root,\n        q,\n        i;\n\n    if (node) quads.push(new Quad(node, x0, y0, x3, y3));\n    if (radius == null) radius = Infinity;\n    else {\n      x0 = x - radius, y0 = y - radius;\n      x3 = x + radius, y3 = y + radius;\n      radius *= radius;\n    }\n\n    while (q = quads.pop()) {\n\n      // Stop searching if this quadrant cant contain a closer node.\n      if (!(node = q.node)\n          || (x1 = q.x0) > x3\n          || (y1 = q.y0) > y3\n          || (x2 = q.x1) < x0\n          || (y2 = q.y1) < y0) continue;\n\n      // Bisect the current quadrant.\n      if (node.length) {\n        var xm = (x1 + x2) / 2,\n            ym = (y1 + y2) / 2;\n\n        quads.push(\n          new Quad(node[3], xm, ym, x2, y2),\n          new Quad(node[2], x1, ym, xm, y2),\n          new Quad(node[1], xm, y1, x2, ym),\n          new Quad(node[0], x1, y1, xm, ym)\n        );\n\n        // Visit the closest quadrant first.\n        if (i = (y >= ym) << 1 | (x >= xm)) {\n          q = quads[quads.length - 1];\n          quads[quads.length - 1] = quads[quads.length - 1 - i];\n          quads[quads.length - 1 - i] = q;\n        }\n      }\n\n      // Visit this point. (Visiting coincident points isnt necessary!)\n      else {\n        var dx = x - +this._x.call(null, node.data),\n            dy = y - +this._y.call(null, node.data),\n            d2 = dx * dx + dy * dy;\n        if (d2 < radius) {\n          var d = Math.sqrt(radius = d2);\n          x0 = x - d, y0 = y - d;\n          x3 = x + d, y3 = y + d;\n          data = node.data;\n        }\n      }\n    }\n\n    return data;\n  }\n\n  function tree_remove(d) {\n    if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points\n\n    var parent,\n        node = this._root,\n        retainer,\n        previous,\n        next,\n        x0 = this._x0,\n        y0 = this._y0,\n        x1 = this._x1,\n        y1 = this._y1,\n        x,\n        y,\n        xm,\n        ym,\n        right,\n        bottom,\n        i,\n        j;\n\n    // If the tree is empty, initialize the root as a leaf.\n    if (!node) return this;\n\n    // Find the leaf node for the point.\n    // While descending, also retain the deepest parent with a non-removed sibling.\n    if (node.length) while (true) {\n      if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;\n      if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;\n      if (!(parent = node, node = node[i = bottom << 1 | right])) return this;\n      if (!node.length) break;\n      if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;\n    }\n\n    // Find the point to remove.\n    while (node.data !== d) if (!(previous = node, node = node.next)) return this;\n    if (next = node.next) delete node.next;\n\n    // If there are multiple coincident points, remove just the point.\n    if (previous) return (next ? previous.next = next : delete previous.next), this;\n\n    // If this is the root point, remove it.\n    if (!parent) return this._root = next, this;\n\n    // Remove this leaf.\n    next ? parent[i] = next : delete parent[i];\n\n    // If the parent now contains exactly one leaf, collapse superfluous parents.\n    if ((node = parent[0] || parent[1] || parent[2] || parent[3])\n        && node === (parent[3] || parent[2] || parent[1] || parent[0])\n        && !node.length) {\n      if (retainer) retainer[j] = node;\n      else this._root = node;\n    }\n\n    return this;\n  }\n\n  function removeAll(data) {\n    for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);\n    return this;\n  }\n\n  function tree_root() {\n    return this._root;\n  }\n\n  function tree_size() {\n    var size = 0;\n    this.visit(function(node) {\n      if (!node.length) do ++size; while (node = node.next)\n    });\n    return size;\n  }\n\n  function tree_visit(callback) {\n    var quads = [], q, node = this._root, child, x0, y0, x1, y1;\n    if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));\n    while (q = quads.pop()) {\n      if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {\n        var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;\n        if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));\n        if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));\n        if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));\n        if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));\n      }\n    }\n    return this;\n  }\n\n  function tree_visitAfter(callback) {\n    var quads = [], next = [], q;\n    if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));\n    while (q = quads.pop()) {\n      var node = q.node;\n      if (node.length) {\n        var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;\n        if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));\n        if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));\n        if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));\n        if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));\n      }\n      next.push(q);\n    }\n    while (q = next.pop()) {\n      callback(q.node, q.x0, q.y0, q.x1, q.y1);\n    }\n    return this;\n  }\n\n  function defaultX(d) {\n    return d[0];\n  }\n\n  function tree_x(_) {\n    return arguments.length ? (this._x = _, this) : this._x;\n  }\n\n  function defaultY(d) {\n    return d[1];\n  }\n\n  function tree_y(_) {\n    return arguments.length ? (this._y = _, this) : this._y;\n  }\n\n  function quadtree(nodes, x, y) {\n    var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);\n    return nodes == null ? tree : tree.addAll(nodes);\n  }\n\n  function Quadtree(x, y, x0, y0, x1, y1) {\n    this._x = x;\n    this._y = y;\n    this._x0 = x0;\n    this._y0 = y0;\n    this._x1 = x1;\n    this._y1 = y1;\n    this._root = undefined;\n  }\n\n  function leaf_copy(leaf) {\n    var copy = {data: leaf.data}, next = copy;\n    while (leaf = leaf.next) next = next.next = {data: leaf.data};\n    return copy;\n  }\n\n  var treeProto = quadtree.prototype = Quadtree.prototype;\n\n  treeProto.copy = function() {\n    var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),\n        node = this._root,\n        nodes,\n        child;\n\n    if (!node) return copy;\n\n    if (!node.length) return copy._root = leaf_copy(node), copy;\n\n    nodes = [{source: node, target: copy._root = new Array(4)}];\n    while (node = nodes.pop()) {\n      for (var i = 0; i < 4; ++i) {\n        if (child = node.source[i]) {\n          if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});\n          else node.target[i] = leaf_copy(child);\n        }\n      }\n    }\n\n    return copy;\n  };\n\n  treeProto.add = tree_add;\n  treeProto.addAll = addAll;\n  treeProto.cover = tree_cover;\n  treeProto.data = tree_data;\n  treeProto.extent = tree_extent;\n  treeProto.find = tree_find;\n  treeProto.remove = tree_remove;\n  treeProto.removeAll = removeAll;\n  treeProto.root = tree_root;\n  treeProto.size = tree_size;\n  treeProto.visit = tree_visit;\n  treeProto.visitAfter = tree_visitAfter;\n  treeProto.x = tree_x;\n  treeProto.y = tree_y;\n\n  exports.quadtree = quadtree;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/d3-quadtree/build/d3-quadtree.js\n ** module id = 3\n ** module chunks = 0\n **/","// https://d3js.org/d3-collection/ Version 1.0.1. Copyright 2016 Mike Bostock.\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.d3 = global.d3 || {})));\n}(this, function (exports) { 'use strict';\n\n  var prefix = \"$\";\n\n  function Map() {}\n\n  Map.prototype = map.prototype = {\n    constructor: Map,\n    has: function(key) {\n      return (prefix + key) in this;\n    },\n    get: function(key) {\n      return this[prefix + key];\n    },\n    set: function(key, value) {\n      this[prefix + key] = value;\n      return this;\n    },\n    remove: function(key) {\n      var property = prefix + key;\n      return property in this && delete this[property];\n    },\n    clear: function() {\n      for (var property in this) if (property[0] === prefix) delete this[property];\n    },\n    keys: function() {\n      var keys = [];\n      for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));\n      return keys;\n    },\n    values: function() {\n      var values = [];\n      for (var property in this) if (property[0] === prefix) values.push(this[property]);\n      return values;\n    },\n    entries: function() {\n      var entries = [];\n      for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});\n      return entries;\n    },\n    size: function() {\n      var size = 0;\n      for (var property in this) if (property[0] === prefix) ++size;\n      return size;\n    },\n    empty: function() {\n      for (var property in this) if (property[0] === prefix) return false;\n      return true;\n    },\n    each: function(f) {\n      for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);\n    }\n  };\n\n  function map(object, f) {\n    var map = new Map;\n\n    // Copy constructor.\n    if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });\n\n    // Index array by numeric index or specified key function.\n    else if (Array.isArray(object)) {\n      var i = -1,\n          n = object.length,\n          o;\n\n      if (f == null) while (++i < n) map.set(i, object[i]);\n      else while (++i < n) map.set(f(o = object[i], i, object), o);\n    }\n\n    // Convert object to map.\n    else if (object) for (var key in object) map.set(key, object[key]);\n\n    return map;\n  }\n\n  function nest() {\n    var keys = [],\n        sortKeys = [],\n        sortValues,\n        rollup,\n        nest;\n\n    function apply(array, depth, createResult, setResult) {\n      if (depth >= keys.length) return rollup != null\n          ? rollup(array) : (sortValues != null\n          ? array.sort(sortValues)\n          : array);\n\n      var i = -1,\n          n = array.length,\n          key = keys[depth++],\n          keyValue,\n          value,\n          valuesByKey = map(),\n          values,\n          result = createResult();\n\n      while (++i < n) {\n        if (values = valuesByKey.get(keyValue = key(value = array[i]) + \"\")) {\n          values.push(value);\n        } else {\n          valuesByKey.set(keyValue, [value]);\n        }\n      }\n\n      valuesByKey.each(function(values, key) {\n        setResult(result, key, apply(values, depth, createResult, setResult));\n      });\n\n      return result;\n    }\n\n    function entries(map, depth) {\n      if (++depth > keys.length) return map;\n      var array, sortKey = sortKeys[depth - 1];\n      if (rollup != null && depth >= keys.length) array = map.entries();\n      else array = [], map.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });\n      return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;\n    }\n\n    return nest = {\n      object: function(array) { return apply(array, 0, createObject, setObject); },\n      map: function(array) { return apply(array, 0, createMap, setMap); },\n      entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },\n      key: function(d) { keys.push(d); return nest; },\n      sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },\n      sortValues: function(order) { sortValues = order; return nest; },\n      rollup: function(f) { rollup = f; return nest; }\n    };\n  }\n\n  function createObject() {\n    return {};\n  }\n\n  function setObject(object, key, value) {\n    object[key] = value;\n  }\n\n  function createMap() {\n    return map();\n  }\n\n  function setMap(map, key, value) {\n    map.set(key, value);\n  }\n\n  function Set() {}\n\n  var proto = map.prototype;\n\n  Set.prototype = set.prototype = {\n    constructor: Set,\n    has: proto.has,\n    add: function(value) {\n      value += \"\";\n      this[prefix + value] = value;\n      return this;\n    },\n    remove: proto.remove,\n    clear: proto.clear,\n    values: proto.keys,\n    size: proto.size,\n    empty: proto.empty,\n    each: proto.each\n  };\n\n  function set(object, f) {\n    var set = new Set;\n\n    // Copy constructor.\n    if (object instanceof Set) object.each(function(value) { set.add(value); });\n\n    // Otherwise, assume its an array.\n    else if (object) {\n      var i = -1, n = object.length;\n      if (f == null) while (++i < n) set.add(object[i]);\n      else while (++i < n) set.add(f(object[i], i, object));\n    }\n\n    return set;\n  }\n\n  function keys(map) {\n    var keys = [];\n    for (var key in map) keys.push(key);\n    return keys;\n  }\n\n  function values(map) {\n    var values = [];\n    for (var key in map) values.push(map[key]);\n    return values;\n  }\n\n  function entries(map) {\n    var entries = [];\n    for (var key in map) entries.push({key: key, value: map[key]});\n    return entries;\n  }\n\n  exports.nest = nest;\n  exports.set = set;\n  exports.map = map;\n  exports.keys = keys;\n  exports.values = values;\n  exports.entries = entries;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/d3-collection/build/d3-collection.js\n ** module id = 4\n ** module chunks = 0\n **/","// https://d3js.org/d3-dispatch/ Version 1.0.1. Copyright 2016 Mike Bostock.\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.d3 = global.d3 || {})));\n}(this, function (exports) { 'use strict';\n\n  var noop = {value: function() {}};\n\n  function dispatch() {\n    for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {\n      if (!(t = arguments[i] + \"\") || (t in _)) throw new Error(\"illegal type: \" + t);\n      _[t] = [];\n    }\n    return new Dispatch(_);\n  }\n\n  function Dispatch(_) {\n    this._ = _;\n  }\n\n  function parseTypenames(typenames, types) {\n    return typenames.trim().split(/^|\\s+/).map(function(t) {\n      var name = \"\", i = t.indexOf(\".\");\n      if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);\n      if (t && !types.hasOwnProperty(t)) throw new Error(\"unknown type: \" + t);\n      return {type: t, name: name};\n    });\n  }\n\n  Dispatch.prototype = dispatch.prototype = {\n    constructor: Dispatch,\n    on: function(typename, callback) {\n      var _ = this._,\n          T = parseTypenames(typename + \"\", _),\n          t,\n          i = -1,\n          n = T.length;\n\n      // If no callback was specified, return the callback of the given type and name.\n      if (arguments.length < 2) {\n        while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;\n        return;\n      }\n\n      // If a type was specified, set the callback for the given type and name.\n      // Otherwise, if a null callback was specified, remove callbacks of the given name.\n      if (callback != null && typeof callback !== \"function\") throw new Error(\"invalid callback: \" + callback);\n      while (++i < n) {\n        if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);\n        else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);\n      }\n\n      return this;\n    },\n    copy: function() {\n      var copy = {}, _ = this._;\n      for (var t in _) copy[t] = _[t].slice();\n      return new Dispatch(copy);\n    },\n    call: function(type, that) {\n      if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];\n      if (!this._.hasOwnProperty(type)) throw new Error(\"unknown type: \" + type);\n      for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);\n    },\n    apply: function(type, that, args) {\n      if (!this._.hasOwnProperty(type)) throw new Error(\"unknown type: \" + type);\n      for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);\n    }\n  };\n\n  function get(type, name) {\n    for (var i = 0, n = type.length, c; i < n; ++i) {\n      if ((c = type[i]).name === name) {\n        return c.value;\n      }\n    }\n  }\n\n  function set(type, name, callback) {\n    for (var i = 0, n = type.length; i < n; ++i) {\n      if (type[i].name === name) {\n        type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));\n        break;\n      }\n    }\n    if (callback != null) type.push({name: name, value: callback});\n    return type;\n  }\n\n  exports.dispatch = dispatch;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/d3-dispatch/build/d3-dispatch.js\n ** module id = 5\n ** module chunks = 0\n **/","// https://d3js.org/d3-timer/ Version 1.0.2. Copyright 2016 Mike Bostock.\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.d3 = global.d3 || {})));\n}(this, function (exports) { 'use strict';\n\n  var frame = 0;\n  var timeout = 0;\n  var interval = 0;\n  var pokeDelay = 1000;\n  var taskHead;\n  var taskTail;\n  var clockLast = 0;\n  var clockNow = 0;\n  var clockSkew = 0;\n  var clock = typeof performance === \"object\" && performance.now ? performance : Date;\n  var setFrame = typeof requestAnimationFrame === \"function\"\n          ? (clock === Date ? function(f) { requestAnimationFrame(function() { f(clock.now()); }); } : requestAnimationFrame)\n          : function(f) { setTimeout(f, 17); };\n  function now() {\n    return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);\n  }\n\n  function clearNow() {\n    clockNow = 0;\n  }\n\n  function Timer() {\n    this._call =\n    this._time =\n    this._next = null;\n  }\n\n  Timer.prototype = timer.prototype = {\n    constructor: Timer,\n    restart: function(callback, delay, time) {\n      if (typeof callback !== \"function\") throw new TypeError(\"callback is not a function\");\n      time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);\n      if (!this._next && taskTail !== this) {\n        if (taskTail) taskTail._next = this;\n        else taskHead = this;\n        taskTail = this;\n      }\n      this._call = callback;\n      this._time = time;\n      sleep();\n    },\n    stop: function() {\n      if (this._call) {\n        this._call = null;\n        this._time = Infinity;\n        sleep();\n      }\n    }\n  };\n\n  function timer(callback, delay, time) {\n    var t = new Timer;\n    t.restart(callback, delay, time);\n    return t;\n  }\n\n  function timerFlush() {\n    now(); // Get the current time, if not already set.\n    ++frame; // Pretend weve set an alarm, if we havent already.\n    var t = taskHead, e;\n    while (t) {\n      if ((e = clockNow - t._time) >= 0) t._call.call(null, e);\n      t = t._next;\n    }\n    --frame;\n  }\n\n  function wake(time) {\n    clockNow = (clockLast = time || clock.now()) + clockSkew;\n    frame = timeout = 0;\n    try {\n      timerFlush();\n    } finally {\n      frame = 0;\n      nap();\n      clockNow = 0;\n    }\n  }\n\n  function poke() {\n    var now = clock.now(), delay = now - clockLast;\n    if (delay > pokeDelay) clockSkew -= delay, clockLast = now;\n  }\n\n  function nap() {\n    var t0, t1 = taskHead, t2, time = Infinity;\n    while (t1) {\n      if (t1._call) {\n        if (time > t1._time) time = t1._time;\n        t0 = t1, t1 = t1._next;\n      } else {\n        t2 = t1._next, t1._next = null;\n        t1 = t0 ? t0._next = t2 : taskHead = t2;\n      }\n    }\n    taskTail = t0;\n    sleep(time);\n  }\n\n  function sleep(time) {\n    if (frame) return; // Soonest alarm already set, or will be.\n    if (timeout) timeout = clearTimeout(timeout);\n    var delay = time - clockNow;\n    if (delay > 24) {\n      if (time < Infinity) timeout = setTimeout(wake, delay);\n      if (interval) interval = clearInterval(interval);\n    } else {\n      if (!interval) interval = setInterval(poke, pokeDelay);\n      frame = 1, setFrame(wake);\n    }\n  }\n\n  function timeout$1(callback, delay, time) {\n    var t = new Timer;\n    delay = delay == null ? 0 : +delay;\n    t.restart(function(elapsed) {\n      t.stop();\n      callback(elapsed + delay);\n    }, delay, time);\n    return t;\n  }\n\n  function interval$1(callback, delay, time) {\n    var t = new Timer, total = delay;\n    if (delay == null) return t.restart(callback, delay, time), t;\n    delay = +delay, time = time == null ? now() : +time;\n    t.restart(function tick(elapsed) {\n      elapsed += total;\n      t.restart(tick, total += delay, time);\n      callback(elapsed);\n    }, delay, time);\n    return t;\n  }\n\n  exports.now = now;\n  exports.timer = timer;\n  exports.timerFlush = timerFlush;\n  exports.timeout = timeout$1;\n  exports.interval = interval$1;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/d3-timer/build/d3-timer.js\n ** module id = 6\n ** module chunks = 0\n **/","module.exports = {\n\t\"nodes\": [\n\t\t{\n\t\t\t\"id\": \"A\"\n\t\t},\n\t\t{\n\t\t\t\"id\": \"B\"\n\t\t},\n\t\t{\n\t\t\t\"id\": \"C\"\n\t\t},\n\t\t{\n\t\t\t\"id\": \"D\"\n\t\t}\n\t],\n\t\"links\": [\n\t\t{\n\t\t\t\"source\": \"A\",\n\t\t\t\"target\": \"B\"\n\t\t},\n\t\t{\n\t\t\t\"source\": \"A\",\n\t\t\t\"target\": \"C\"\n\t\t},\n\t\t{\n\t\t\t\"source\": \"A\",\n\t\t\t\"target\": \"D\"\n\t\t},\n\t\t{\n\t\t\t\"source\": \"B\",\n\t\t\t\"target\": \"D\"\n\t\t}\n\t]\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/js/data.json\n ** module id = 7\n ** module chunks = 0\n **/"],"sourceRoot":""}
{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///giraph.min.js","webpack:///webpack/bootstrap 2898af064a9d1187eedd","webpack:///./src/bundle.js","webpack:///./src/js/app.js","webpack:///./~/d3-force/build/d3-force.js","webpack:///./~/d3-quadtree/build/d3-quadtree.js","webpack:///./~/d3-collection/build/d3-collection.js","webpack:///./~/d3-dispatch/build/d3-dispatch.js","webpack:///./~/d3-timer/build/d3-timer.js","webpack:///./src/js/data.json","webpack:///./src/js/giraph.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","redraw","context","clearRect","width","height","beginPath","graph","links","forEach","drawLink","stroke","nodes","drawNode","fill","d","moveTo","source","x","y","lineTo","target","arc","Math","PI","d3","canvas","document","createElement","body","appendChild","querySelector","getContext","simulation","forceSimulation","force","forceLink","forceManyBody","forceCenter","on","distance","global","d3Quadtree","d3Collection","d3Dispatch","d3Timer","center","i","node","n","length","sx","sy","initialize","_","arguments","constant","jiggle","random","vx","vy","collide","radius","apply","quad","x0","y0","x1","y1","data","rj","r","ri","xi","yi","index","l","sqrt","strength","ri2","tree","k","iterations","quadtree","visitAfter","prepare","radii","visit","Array","link","defaultStrength","min","count","alpha","b","distances","strengths","bias","nodeById","map","get","initializeStrength","initializeDistance","x$1","y$1","step","tick","event","alphaMin","stepper","stop","alphaTarget","alphaDecay","forces","each","fx","velocityDecay","fy","initializeNodes","isNaN","initialRadius","angle","initialAngle","cos","sin","initializeForce","pow","timer","dispatch","restart","name","remove","set","find","dx","dy","d2","closest","Infinity","manyBody","accumulate","q","value","next","x2","w","theta2","distanceMax2","distanceMin2","distanceMin","distanceMax","theta","x$2","xz","y$2","yz","forceCollide","forceX","forceY","Object","defineProperty","tree_add","_x","_y","add","cover","parent","xm","ym","xp","yp","right","bottom","j","_root","leaf","_x0","_y0","_x1","_y1","addAll","tree_cover","floor","z","tree_data","push","tree_extent","undefined","Quad","tree_find","y2","x3","y3","quads","pop","tree_remove","retainer","previous","removeAll","tree_root","tree_size","size","tree_visit","callback","child","tree_visitAfter","defaultX","tree_x","defaultY","tree_y","Quadtree","NaN","leaf_copy","copy","treeProto","prototype","extent","Map","object","f","key","isArray","o","nest","array","depth","createResult","setResult","keys","rollup","sortValues","sort","keyValue","values","valuesByKey","result","entries","sortKey","sortKeys","v","a","createObject","setObject","createMap","setMap","order","Set","prefix","constructor","has","property","clear","slice","empty","proto","t","Error","Dispatch","parseTypenames","typenames","types","trim","split","indexOf","hasOwnProperty","type","noop","concat","typename","T","that","args","now","clockNow","setFrame","clearNow","clock","clockSkew","Timer","_call","_time","_next","delay","time","timerFlush","frame","e","taskHead","wake","clockLast","timeout","nap","poke","pokeDelay","t0","t2","t1","taskTail","sleep","clearTimeout","setTimeout","interval","clearInterval","setInterval","timeout$1","elapsed","interval$1","total","performance","Date","requestAnimationFrame","TypeError","_classCallCheck","instance","Constructor","_createClass","defineProperties","props","descriptor","enumerable","configurable","writable","protoProps","staticProps","Giraph","options"],"mappings":"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","file":"giraph.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Giraph\"] = factory();\n\telse\n\t\troot[\"Giraph\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Giraph\"] = factory();\n\telse\n\t\troot[\"Giraph\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t// Currently this require here adds side effects\n\t__webpack_require__(1);\n\t\n\t// Main export\n\tmodule.exports = __webpack_require__(8);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar d3 = __webpack_require__(2);\n\tvar graph = __webpack_require__(7);\n\t\n\tvar canvas = document.createElement('canvas');\n\tdocument.body.appendChild(canvas);\n\t\n\tvar canvas = document.querySelector(\"canvas\"),\n\t    context = canvas.getContext(\"2d\"),\n\t    width = canvas.width,\n\t    height = canvas.height;\n\t\n\tvar simulation = d3.forceSimulation().force(\"link\", d3.forceLink().id(function (d) {\n\t    return d.id;\n\t})).force(\"charge\", d3.forceManyBody()).force(\"center\", d3.forceCenter(width / 2, height / 2));\n\t\n\tsimulation.nodes(graph.nodes).on(\"tick\", redraw);\n\t\n\tsimulation.force(\"link\").links(graph.links).distance(function (d) {\n\t    return 100;\n\t});\n\t\n\tfunction redraw() {\n\t    context.clearRect(0, 0, width, height);\n\t\n\t    context.beginPath();\n\t    graph.links.forEach(drawLink);\n\t    context.stroke();\n\t\n\t    context.beginPath();\n\t    graph.nodes.forEach(drawNode);\n\t    context.fill();\n\t}\n\t\n\tfunction drawLink(d) {\n\t    context.moveTo(d.source.x, d.source.y);\n\t    context.lineTo(d.target.x, d.target.y);\n\t}\n\t\n\tfunction drawNode(d) {\n\t    context.moveTo(d.x + 3, d.y);\n\t    context.arc(d.x, d.y, 20, 0, 2 * Math.PI);\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// https://d3js.org/d3-force/ Version 1.0.2. Copyright 2016 Mike Bostock.\n\t(function (global, factory) {\n\t   true ? factory(exports, __webpack_require__(3), __webpack_require__(4), __webpack_require__(5), __webpack_require__(6)) :\n\t  typeof define === 'function' && define.amd ? define(['exports', 'd3-quadtree', 'd3-collection', 'd3-dispatch', 'd3-timer'], factory) :\n\t  (factory((global.d3 = global.d3 || {}),global.d3,global.d3,global.d3,global.d3));\n\t}(this, function (exports,d3Quadtree,d3Collection,d3Dispatch,d3Timer) { 'use strict';\n\t\n\t  function center(x, y) {\n\t    var nodes;\n\t\n\t    if (x == null) x = 0;\n\t    if (y == null) y = 0;\n\t\n\t    function force() {\n\t      var i,\n\t          n = nodes.length,\n\t          node,\n\t          sx = 0,\n\t          sy = 0;\n\t\n\t      for (i = 0; i < n; ++i) {\n\t        node = nodes[i], sx += node.x, sy += node.y;\n\t      }\n\t\n\t      for (sx = sx / n - x, sy = sy / n - y, i = 0; i < n; ++i) {\n\t        node = nodes[i], node.x -= sx, node.y -= sy;\n\t      }\n\t    }\n\t\n\t    force.initialize = function(_) {\n\t      nodes = _;\n\t    };\n\t\n\t    force.x = function(_) {\n\t      return arguments.length ? (x = +_, force) : x;\n\t    };\n\t\n\t    force.y = function(_) {\n\t      return arguments.length ? (y = +_, force) : y;\n\t    };\n\t\n\t    return force;\n\t  }\n\t\n\t  function constant(x) {\n\t    return function() {\n\t      return x;\n\t    };\n\t  }\n\t\n\t  function jiggle() {\n\t    return (Math.random() - 0.5) * 1e-6;\n\t  }\n\t\n\t  function x(d) {\n\t    return d.x + d.vx;\n\t  }\n\t\n\t  function y(d) {\n\t    return d.y + d.vy;\n\t  }\n\t\n\t  function collide(radius) {\n\t    var nodes,\n\t        radii,\n\t        strength = 1,\n\t        iterations = 1;\n\t\n\t    if (typeof radius !== \"function\") radius = constant(radius == null ? 1 : +radius);\n\t\n\t    function force() {\n\t      var i, n = nodes.length,\n\t          tree,\n\t          node,\n\t          xi,\n\t          yi,\n\t          ri,\n\t          ri2;\n\t\n\t      for (var k = 0; k < iterations; ++k) {\n\t        tree = d3Quadtree.quadtree(nodes, x, y).visitAfter(prepare);\n\t        for (i = 0; i < n; ++i) {\n\t          node = nodes[i];\n\t          ri = radii[i], ri2 = ri * ri;\n\t          xi = node.x + node.vx;\n\t          yi = node.y + node.vy;\n\t          tree.visit(apply);\n\t        }\n\t      }\n\t\n\t      function apply(quad, x0, y0, x1, y1) {\n\t        var data = quad.data, rj = quad.r, r = ri + rj;\n\t        if (data) {\n\t          if (data.index > i) {\n\t            var x = xi - data.x - data.vx,\n\t                y = yi - data.y - data.vy,\n\t                l = x * x + y * y;\n\t            if (l < r * r) {\n\t              if (x === 0) x = jiggle(), l += x * x;\n\t              if (y === 0) y = jiggle(), l += y * y;\n\t              l = (r - (l = Math.sqrt(l))) / l * strength;\n\t              node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));\n\t              node.vy += (y *= l) * r;\n\t              data.vx -= x * (r = 1 - r);\n\t              data.vy -= y * r;\n\t            }\n\t          }\n\t          return;\n\t        }\n\t        return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;\n\t      }\n\t    }\n\t\n\t    function prepare(quad) {\n\t      if (quad.data) return quad.r = radii[quad.data.index];\n\t      for (var i = quad.r = 0; i < 4; ++i) {\n\t        if (quad[i] && quad[i].r > quad.r) {\n\t          quad.r = quad[i].r;\n\t        }\n\t      }\n\t    }\n\t\n\t    force.initialize = function(_) {\n\t      var i, n = (nodes = _).length; radii = new Array(n);\n\t      for (i = 0; i < n; ++i) radii[i] = +radius(nodes[i], i, nodes);\n\t    };\n\t\n\t    force.iterations = function(_) {\n\t      return arguments.length ? (iterations = +_, force) : iterations;\n\t    };\n\t\n\t    force.strength = function(_) {\n\t      return arguments.length ? (strength = +_, force) : strength;\n\t    };\n\t\n\t    force.radius = function(_) {\n\t      return arguments.length ? (radius = typeof _ === \"function\" ? _ : constant(+_), force) : radius;\n\t    };\n\t\n\t    return force;\n\t  }\n\t\n\t  function index(d, i) {\n\t    return i;\n\t  }\n\t\n\t  function link(links) {\n\t    var id = index,\n\t        strength = defaultStrength,\n\t        strengths,\n\t        distance = constant(30),\n\t        distances,\n\t        nodes,\n\t        count,\n\t        bias,\n\t        iterations = 1;\n\t\n\t    if (links == null) links = [];\n\t\n\t    function defaultStrength(link) {\n\t      return 1 / Math.min(count[link.source.index], count[link.target.index]);\n\t    }\n\t\n\t    function force(alpha) {\n\t      for (var k = 0, n = links.length; k < iterations; ++k) {\n\t        for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {\n\t          link = links[i], source = link.source, target = link.target;\n\t          x = target.x + target.vx - source.x - source.vx || jiggle();\n\t          y = target.y + target.vy - source.y - source.vy || jiggle();\n\t          l = Math.sqrt(x * x + y * y);\n\t          l = (l - distances[i]) / l * alpha * strengths[i];\n\t          x *= l, y *= l;\n\t          target.vx -= x * (b = bias[i]);\n\t          target.vy -= y * b;\n\t          source.vx += x * (b = 1 - b);\n\t          source.vy += y * b;\n\t        }\n\t      }\n\t    }\n\t\n\t    function initialize() {\n\t      if (!nodes) return;\n\t\n\t      var i,\n\t          n = nodes.length,\n\t          m = links.length,\n\t          nodeById = d3Collection.map(nodes, id),\n\t          link;\n\t\n\t      for (i = 0, count = new Array(n); i < n; ++i) {\n\t        count[i] = 0;\n\t      }\n\t\n\t      for (i = 0; i < m; ++i) {\n\t        link = links[i], link.index = i;\n\t        if (typeof link.source !== \"object\") link.source = nodeById.get(link.source);\n\t        if (typeof link.target !== \"object\") link.target = nodeById.get(link.target);\n\t        ++count[link.source.index], ++count[link.target.index];\n\t      }\n\t\n\t      for (i = 0, bias = new Array(m); i < m; ++i) {\n\t        link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);\n\t      }\n\t\n\t      strengths = new Array(m), initializeStrength();\n\t      distances = new Array(m), initializeDistance();\n\t    }\n\t\n\t    function initializeStrength() {\n\t      if (!nodes) return;\n\t\n\t      for (var i = 0, n = links.length; i < n; ++i) {\n\t        strengths[i] = +strength(links[i], i, links);\n\t      }\n\t    }\n\t\n\t    function initializeDistance() {\n\t      if (!nodes) return;\n\t\n\t      for (var i = 0, n = links.length; i < n; ++i) {\n\t        distances[i] = +distance(links[i], i, links);\n\t      }\n\t    }\n\t\n\t    force.initialize = function(_) {\n\t      nodes = _;\n\t      initialize();\n\t    };\n\t\n\t    force.links = function(_) {\n\t      return arguments.length ? (links = _, initialize(), force) : links;\n\t    };\n\t\n\t    force.id = function(_) {\n\t      return arguments.length ? (id = _, force) : id;\n\t    };\n\t\n\t    force.iterations = function(_) {\n\t      return arguments.length ? (iterations = +_, force) : iterations;\n\t    };\n\t\n\t    force.strength = function(_) {\n\t      return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant(+_), initializeStrength(), force) : strength;\n\t    };\n\t\n\t    force.distance = function(_) {\n\t      return arguments.length ? (distance = typeof _ === \"function\" ? _ : constant(+_), initializeDistance(), force) : distance;\n\t    };\n\t\n\t    return force;\n\t  }\n\t\n\t  function x$1(d) {\n\t    return d.x;\n\t  }\n\t\n\t  function y$1(d) {\n\t    return d.y;\n\t  }\n\t\n\t  var initialRadius = 10;\n\t  var initialAngle = Math.PI * (3 - Math.sqrt(5));\n\t  function simulation(nodes) {\n\t    var simulation,\n\t        alpha = 1,\n\t        alphaMin = 0.001,\n\t        alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),\n\t        alphaTarget = 0,\n\t        velocityDecay = 0.6,\n\t        forces = d3Collection.map(),\n\t        stepper = d3Timer.timer(step),\n\t        event = d3Dispatch.dispatch(\"tick\", \"end\");\n\t\n\t    if (nodes == null) nodes = [];\n\t\n\t    function step() {\n\t      tick();\n\t      event.call(\"tick\", simulation);\n\t      if (alpha < alphaMin) {\n\t        stepper.stop();\n\t        event.call(\"end\", simulation);\n\t      }\n\t    }\n\t\n\t    function tick() {\n\t      var i, n = nodes.length, node;\n\t\n\t      alpha += (alphaTarget - alpha) * alphaDecay;\n\t\n\t      forces.each(function(force) {\n\t        force(alpha);\n\t      });\n\t\n\t      for (i = 0; i < n; ++i) {\n\t        node = nodes[i];\n\t        if (node.fx == null) node.x += node.vx *= velocityDecay;\n\t        else node.x = node.fx, node.vx = 0;\n\t        if (node.fy == null) node.y += node.vy *= velocityDecay;\n\t        else node.y = node.fy, node.vy = 0;\n\t      }\n\t    }\n\t\n\t    function initializeNodes() {\n\t      for (var i = 0, n = nodes.length, node; i < n; ++i) {\n\t        node = nodes[i], node.index = i;\n\t        if (isNaN(node.x) || isNaN(node.y)) {\n\t          var radius = initialRadius * Math.sqrt(i), angle = i * initialAngle;\n\t          node.x = radius * Math.cos(angle);\n\t          node.y = radius * Math.sin(angle);\n\t        }\n\t        if (isNaN(node.vx) || isNaN(node.vy)) {\n\t          node.vx = node.vy = 0;\n\t        }\n\t      }\n\t    }\n\t\n\t    function initializeForce(force) {\n\t      if (force.initialize) force.initialize(nodes);\n\t      return force;\n\t    }\n\t\n\t    initializeNodes();\n\t\n\t    return simulation = {\n\t      tick: tick,\n\t\n\t      restart: function() {\n\t        return stepper.restart(step), simulation;\n\t      },\n\t\n\t      stop: function() {\n\t        return stepper.stop(), simulation;\n\t      },\n\t\n\t      nodes: function(_) {\n\t        return arguments.length ? (nodes = _, initializeNodes(), forces.each(initializeForce), simulation) : nodes;\n\t      },\n\t\n\t      alpha: function(_) {\n\t        return arguments.length ? (alpha = +_, simulation) : alpha;\n\t      },\n\t\n\t      alphaMin: function(_) {\n\t        return arguments.length ? (alphaMin = +_, simulation) : alphaMin;\n\t      },\n\t\n\t      alphaDecay: function(_) {\n\t        return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;\n\t      },\n\t\n\t      alphaTarget: function(_) {\n\t        return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;\n\t      },\n\t\n\t      velocityDecay: function(_) {\n\t        return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;\n\t      },\n\t\n\t      force: function(name, _) {\n\t        return arguments.length > 1 ? ((_ == null ? forces.remove(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);\n\t      },\n\t\n\t      find: function(x, y, radius) {\n\t        var i = 0,\n\t            n = nodes.length,\n\t            dx,\n\t            dy,\n\t            d2,\n\t            node,\n\t            closest;\n\t\n\t        if (radius == null) radius = Infinity;\n\t        else radius *= radius;\n\t\n\t        for (i = 0; i < n; ++i) {\n\t          node = nodes[i];\n\t          dx = x - node.x;\n\t          dy = y - node.y;\n\t          d2 = dx * dx + dy * dy;\n\t          if (d2 < radius) closest = node, radius = d2;\n\t        }\n\t\n\t        return closest;\n\t      },\n\t\n\t      on: function(name, _) {\n\t        return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);\n\t      }\n\t    };\n\t  }\n\t\n\t  function manyBody() {\n\t    var nodes,\n\t        node,\n\t        alpha,\n\t        strength = constant(-30),\n\t        strengths,\n\t        distanceMin2 = 1,\n\t        distanceMax2 = Infinity,\n\t        theta2 = 0.81;\n\t\n\t    function force(_) {\n\t      var i, n = nodes.length, tree = d3Quadtree.quadtree(nodes, x$1, y$1).visitAfter(accumulate);\n\t      for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);\n\t    }\n\t\n\t    function initialize() {\n\t      if (!nodes) return;\n\t      var i, n = nodes.length;\n\t      strengths = new Array(n);\n\t      for (i = 0; i < n; ++i) strengths[i] = +strength(nodes[i], i, nodes);\n\t    }\n\t\n\t    function accumulate(quad) {\n\t      var strength = 0, q, c, x, y, i;\n\t\n\t      // For internal nodes, accumulate forces from child quadrants.\n\t      if (quad.length) {\n\t        for (x = y = i = 0; i < 4; ++i) {\n\t          if ((q = quad[i]) && (c = q.value)) {\n\t            strength += c, x += c * q.x, y += c * q.y;\n\t          }\n\t        }\n\t        quad.x = x / strength;\n\t        quad.y = y / strength;\n\t      }\n\t\n\t      // For leaf nodes, accumulate forces from coincident quadrants.\n\t      else {\n\t        q = quad;\n\t        q.x = q.data.x;\n\t        q.y = q.data.y;\n\t        do strength += strengths[q.data.index];\n\t        while (q = q.next);\n\t      }\n\t\n\t      quad.value = strength;\n\t    }\n\t\n\t    function apply(quad, x1, _, x2) {\n\t      if (!quad.value) return true;\n\t\n\t      var x = quad.x - node.x,\n\t          y = quad.y - node.y,\n\t          w = x2 - x1,\n\t          l = x * x + y * y;\n\t\n\t      // Apply the Barnes-Hut approximation if possible.\n\t      // Limit forces for very close nodes; randomize direction if coincident.\n\t      if (w * w / theta2 < l) {\n\t        if (l < distanceMax2) {\n\t          if (x === 0) x = jiggle(), l += x * x;\n\t          if (y === 0) y = jiggle(), l += y * y;\n\t          if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);\n\t          node.vx += x * quad.value * alpha / l;\n\t          node.vy += y * quad.value * alpha / l;\n\t        }\n\t        return true;\n\t      }\n\t\n\t      // Otherwise, process points directly.\n\t      else if (quad.length || l >= distanceMax2) return;\n\t\n\t      // Limit forces for very close nodes; randomize direction if coincident.\n\t      if (quad.data !== node || quad.next) {\n\t        if (x === 0) x = jiggle(), l += x * x;\n\t        if (y === 0) y = jiggle(), l += y * y;\n\t        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);\n\t      }\n\t\n\t      do if (quad.data !== node) {\n\t        w = strengths[quad.data.index] * alpha / l;\n\t        node.vx += x * w;\n\t        node.vy += y * w;\n\t      } while (quad = quad.next);\n\t    }\n\t\n\t    force.initialize = function(_) {\n\t      nodes = _;\n\t      initialize();\n\t    };\n\t\n\t    force.strength = function(_) {\n\t      return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant(+_), initialize(), force) : strength;\n\t    };\n\t\n\t    force.distanceMin = function(_) {\n\t      return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);\n\t    };\n\t\n\t    force.distanceMax = function(_) {\n\t      return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);\n\t    };\n\t\n\t    force.theta = function(_) {\n\t      return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);\n\t    };\n\t\n\t    return force;\n\t  }\n\t\n\t  function x$2(x) {\n\t    var strength = constant(0.1),\n\t        nodes,\n\t        strengths,\n\t        xz;\n\t\n\t    if (typeof x !== \"function\") x = constant(x == null ? 0 : +x);\n\t\n\t    function force(alpha) {\n\t      for (var i = 0, n = nodes.length, node; i < n; ++i) {\n\t        node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;\n\t      }\n\t    }\n\t\n\t    function initialize() {\n\t      if (!nodes) return;\n\t      var i, n = nodes.length;\n\t      strengths = new Array(n);\n\t      xz = new Array(n);\n\t      for (i = 0; i < n; ++i) {\n\t        strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);\n\t      }\n\t    }\n\t\n\t    force.initialize = function(_) {\n\t      nodes = _;\n\t      initialize();\n\t    };\n\t\n\t    force.strength = function(_) {\n\t      return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant(+_), initialize(), force) : strength;\n\t    };\n\t\n\t    force.x = function(_) {\n\t      return arguments.length ? (x = typeof _ === \"function\" ? _ : constant(+_), initialize(), force) : x;\n\t    };\n\t\n\t    return force;\n\t  }\n\t\n\t  function y$2(y) {\n\t    var strength = constant(0.1),\n\t        nodes,\n\t        strengths,\n\t        yz;\n\t\n\t    if (typeof y !== \"function\") y = constant(y == null ? 0 : +y);\n\t\n\t    function force(alpha) {\n\t      for (var i = 0, n = nodes.length, node; i < n; ++i) {\n\t        node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;\n\t      }\n\t    }\n\t\n\t    function initialize() {\n\t      if (!nodes) return;\n\t      var i, n = nodes.length;\n\t      strengths = new Array(n);\n\t      yz = new Array(n);\n\t      for (i = 0; i < n; ++i) {\n\t        strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);\n\t      }\n\t    }\n\t\n\t    force.initialize = function(_) {\n\t      nodes = _;\n\t      initialize();\n\t    };\n\t\n\t    force.strength = function(_) {\n\t      return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant(+_), initialize(), force) : strength;\n\t    };\n\t\n\t    force.y = function(_) {\n\t      return arguments.length ? (y = typeof _ === \"function\" ? _ : constant(+_), initialize(), force) : y;\n\t    };\n\t\n\t    return force;\n\t  }\n\t\n\t  exports.forceCenter = center;\n\t  exports.forceCollide = collide;\n\t  exports.forceLink = link;\n\t  exports.forceManyBody = manyBody;\n\t  exports.forceSimulation = simulation;\n\t  exports.forceX = x$2;\n\t  exports.forceY = y$2;\n\t\n\t  Object.defineProperty(exports, '__esModule', { value: true });\n\t\n\t}));\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// https://d3js.org/d3-quadtree/ Version 1.0.1. Copyright 2016 Mike Bostock.\n\t(function (global, factory) {\n\t   true ? factory(exports) :\n\t  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t  (factory((global.d3 = global.d3 || {})));\n\t}(this, function (exports) { 'use strict';\n\t\n\t  function tree_add(d) {\n\t    var x = +this._x.call(null, d),\n\t        y = +this._y.call(null, d);\n\t    return add(this.cover(x, y), x, y, d);\n\t  }\n\t\n\t  function add(tree, x, y, d) {\n\t    if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points\n\t\n\t    var parent,\n\t        node = tree._root,\n\t        leaf = {data: d},\n\t        x0 = tree._x0,\n\t        y0 = tree._y0,\n\t        x1 = tree._x1,\n\t        y1 = tree._y1,\n\t        xm,\n\t        ym,\n\t        xp,\n\t        yp,\n\t        right,\n\t        bottom,\n\t        i,\n\t        j;\n\t\n\t    // If the tree is empty, initialize the root as a leaf.\n\t    if (!node) return tree._root = leaf, tree;\n\t\n\t    // Find the existing leaf for the new point, or add it.\n\t    while (node.length) {\n\t      if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;\n\t      if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;\n\t      if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;\n\t    }\n\t\n\t    // Is the new point is exactly coincident with the existing point?\n\t    xp = +tree._x.call(null, node.data);\n\t    yp = +tree._y.call(null, node.data);\n\t    if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;\n\t\n\t    // Otherwise, split the leaf node until the old and new point are separated.\n\t    do {\n\t      parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);\n\t      if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;\n\t      if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;\n\t    } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));\n\t    return parent[j] = node, parent[i] = leaf, tree;\n\t  }\n\t\n\t  function addAll(data) {\n\t    var d, i, n = data.length,\n\t        x,\n\t        y,\n\t        xz = new Array(n),\n\t        yz = new Array(n),\n\t        x0 = Infinity,\n\t        y0 = Infinity,\n\t        x1 = -Infinity,\n\t        y1 = -Infinity;\n\t\n\t    // Compute the points and their extent.\n\t    for (i = 0; i < n; ++i) {\n\t      if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;\n\t      xz[i] = x;\n\t      yz[i] = y;\n\t      if (x < x0) x0 = x;\n\t      if (x > x1) x1 = x;\n\t      if (y < y0) y0 = y;\n\t      if (y > y1) y1 = y;\n\t    }\n\t\n\t    // If there were no (valid) points, inherit the existing extent.\n\t    if (x1 < x0) x0 = this._x0, x1 = this._x1;\n\t    if (y1 < y0) y0 = this._y0, y1 = this._y1;\n\t\n\t    // Expand the tree to cover the new points.\n\t    this.cover(x0, y0).cover(x1, y1);\n\t\n\t    // Add the new points.\n\t    for (i = 0; i < n; ++i) {\n\t      add(this, xz[i], yz[i], data[i]);\n\t    }\n\t\n\t    return this;\n\t  }\n\t\n\t  function tree_cover(x, y) {\n\t    if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points\n\t\n\t    var x0 = this._x0,\n\t        y0 = this._y0,\n\t        x1 = this._x1,\n\t        y1 = this._y1;\n\t\n\t    // If the quadtree has no extent, initialize them.\n\t    // Integer extent are necessary so that if we later double the extent,\n\t    // the existing quadrant boundaries don’t change due to floating point error!\n\t    if (isNaN(x0)) {\n\t      x1 = (x0 = Math.floor(x)) + 1;\n\t      y1 = (y0 = Math.floor(y)) + 1;\n\t    }\n\t\n\t    // Otherwise, double repeatedly to cover.\n\t    else if (x0 > x || x > x1 || y0 > y || y > y1) {\n\t      var z = x1 - x0,\n\t          node = this._root,\n\t          parent,\n\t          i;\n\t\n\t      switch (i = (y < (y0 + y1) / 2) << 1 | (x < (x0 + x1) / 2)) {\n\t        case 0: {\n\t          do parent = new Array(4), parent[i] = node, node = parent;\n\t          while (z *= 2, x1 = x0 + z, y1 = y0 + z, x > x1 || y > y1);\n\t          break;\n\t        }\n\t        case 1: {\n\t          do parent = new Array(4), parent[i] = node, node = parent;\n\t          while (z *= 2, x0 = x1 - z, y1 = y0 + z, x0 > x || y > y1);\n\t          break;\n\t        }\n\t        case 2: {\n\t          do parent = new Array(4), parent[i] = node, node = parent;\n\t          while (z *= 2, x1 = x0 + z, y0 = y1 - z, x > x1 || y0 > y);\n\t          break;\n\t        }\n\t        case 3: {\n\t          do parent = new Array(4), parent[i] = node, node = parent;\n\t          while (z *= 2, x0 = x1 - z, y0 = y1 - z, x0 > x || y0 > y);\n\t          break;\n\t        }\n\t      }\n\t\n\t      if (this._root && this._root.length) this._root = node;\n\t    }\n\t\n\t    // If the quadtree covers the point already, just return.\n\t    else return this;\n\t\n\t    this._x0 = x0;\n\t    this._y0 = y0;\n\t    this._x1 = x1;\n\t    this._y1 = y1;\n\t    return this;\n\t  }\n\t\n\t  function tree_data() {\n\t    var data = [];\n\t    this.visit(function(node) {\n\t      if (!node.length) do data.push(node.data); while (node = node.next)\n\t    });\n\t    return data;\n\t  }\n\t\n\t  function tree_extent(_) {\n\t    return arguments.length\n\t        ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])\n\t        : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];\n\t  }\n\t\n\t  function Quad(node, x0, y0, x1, y1) {\n\t    this.node = node;\n\t    this.x0 = x0;\n\t    this.y0 = y0;\n\t    this.x1 = x1;\n\t    this.y1 = y1;\n\t  }\n\t\n\t  function tree_find(x, y, radius) {\n\t    var data,\n\t        x0 = this._x0,\n\t        y0 = this._y0,\n\t        x1,\n\t        y1,\n\t        x2,\n\t        y2,\n\t        x3 = this._x1,\n\t        y3 = this._y1,\n\t        quads = [],\n\t        node = this._root,\n\t        q,\n\t        i;\n\t\n\t    if (node) quads.push(new Quad(node, x0, y0, x3, y3));\n\t    if (radius == null) radius = Infinity;\n\t    else {\n\t      x0 = x - radius, y0 = y - radius;\n\t      x3 = x + radius, y3 = y + radius;\n\t      radius *= radius;\n\t    }\n\t\n\t    while (q = quads.pop()) {\n\t\n\t      // Stop searching if this quadrant can’t contain a closer node.\n\t      if (!(node = q.node)\n\t          || (x1 = q.x0) > x3\n\t          || (y1 = q.y0) > y3\n\t          || (x2 = q.x1) < x0\n\t          || (y2 = q.y1) < y0) continue;\n\t\n\t      // Bisect the current quadrant.\n\t      if (node.length) {\n\t        var xm = (x1 + x2) / 2,\n\t            ym = (y1 + y2) / 2;\n\t\n\t        quads.push(\n\t          new Quad(node[3], xm, ym, x2, y2),\n\t          new Quad(node[2], x1, ym, xm, y2),\n\t          new Quad(node[1], xm, y1, x2, ym),\n\t          new Quad(node[0], x1, y1, xm, ym)\n\t        );\n\t\n\t        // Visit the closest quadrant first.\n\t        if (i = (y >= ym) << 1 | (x >= xm)) {\n\t          q = quads[quads.length - 1];\n\t          quads[quads.length - 1] = quads[quads.length - 1 - i];\n\t          quads[quads.length - 1 - i] = q;\n\t        }\n\t      }\n\t\n\t      // Visit this point. (Visiting coincident points isn’t necessary!)\n\t      else {\n\t        var dx = x - +this._x.call(null, node.data),\n\t            dy = y - +this._y.call(null, node.data),\n\t            d2 = dx * dx + dy * dy;\n\t        if (d2 < radius) {\n\t          var d = Math.sqrt(radius = d2);\n\t          x0 = x - d, y0 = y - d;\n\t          x3 = x + d, y3 = y + d;\n\t          data = node.data;\n\t        }\n\t      }\n\t    }\n\t\n\t    return data;\n\t  }\n\t\n\t  function tree_remove(d) {\n\t    if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points\n\t\n\t    var parent,\n\t        node = this._root,\n\t        retainer,\n\t        previous,\n\t        next,\n\t        x0 = this._x0,\n\t        y0 = this._y0,\n\t        x1 = this._x1,\n\t        y1 = this._y1,\n\t        x,\n\t        y,\n\t        xm,\n\t        ym,\n\t        right,\n\t        bottom,\n\t        i,\n\t        j;\n\t\n\t    // If the tree is empty, initialize the root as a leaf.\n\t    if (!node) return this;\n\t\n\t    // Find the leaf node for the point.\n\t    // While descending, also retain the deepest parent with a non-removed sibling.\n\t    if (node.length) while (true) {\n\t      if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;\n\t      if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;\n\t      if (!(parent = node, node = node[i = bottom << 1 | right])) return this;\n\t      if (!node.length) break;\n\t      if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;\n\t    }\n\t\n\t    // Find the point to remove.\n\t    while (node.data !== d) if (!(previous = node, node = node.next)) return this;\n\t    if (next = node.next) delete node.next;\n\t\n\t    // If there are multiple coincident points, remove just the point.\n\t    if (previous) return (next ? previous.next = next : delete previous.next), this;\n\t\n\t    // If this is the root point, remove it.\n\t    if (!parent) return this._root = next, this;\n\t\n\t    // Remove this leaf.\n\t    next ? parent[i] = next : delete parent[i];\n\t\n\t    // If the parent now contains exactly one leaf, collapse superfluous parents.\n\t    if ((node = parent[0] || parent[1] || parent[2] || parent[3])\n\t        && node === (parent[3] || parent[2] || parent[1] || parent[0])\n\t        && !node.length) {\n\t      if (retainer) retainer[j] = node;\n\t      else this._root = node;\n\t    }\n\t\n\t    return this;\n\t  }\n\t\n\t  function removeAll(data) {\n\t    for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);\n\t    return this;\n\t  }\n\t\n\t  function tree_root() {\n\t    return this._root;\n\t  }\n\t\n\t  function tree_size() {\n\t    var size = 0;\n\t    this.visit(function(node) {\n\t      if (!node.length) do ++size; while (node = node.next)\n\t    });\n\t    return size;\n\t  }\n\t\n\t  function tree_visit(callback) {\n\t    var quads = [], q, node = this._root, child, x0, y0, x1, y1;\n\t    if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));\n\t    while (q = quads.pop()) {\n\t      if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {\n\t        var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;\n\t        if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));\n\t        if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));\n\t        if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));\n\t        if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));\n\t      }\n\t    }\n\t    return this;\n\t  }\n\t\n\t  function tree_visitAfter(callback) {\n\t    var quads = [], next = [], q;\n\t    if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));\n\t    while (q = quads.pop()) {\n\t      var node = q.node;\n\t      if (node.length) {\n\t        var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;\n\t        if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));\n\t        if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));\n\t        if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));\n\t        if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));\n\t      }\n\t      next.push(q);\n\t    }\n\t    while (q = next.pop()) {\n\t      callback(q.node, q.x0, q.y0, q.x1, q.y1);\n\t    }\n\t    return this;\n\t  }\n\t\n\t  function defaultX(d) {\n\t    return d[0];\n\t  }\n\t\n\t  function tree_x(_) {\n\t    return arguments.length ? (this._x = _, this) : this._x;\n\t  }\n\t\n\t  function defaultY(d) {\n\t    return d[1];\n\t  }\n\t\n\t  function tree_y(_) {\n\t    return arguments.length ? (this._y = _, this) : this._y;\n\t  }\n\t\n\t  function quadtree(nodes, x, y) {\n\t    var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);\n\t    return nodes == null ? tree : tree.addAll(nodes);\n\t  }\n\t\n\t  function Quadtree(x, y, x0, y0, x1, y1) {\n\t    this._x = x;\n\t    this._y = y;\n\t    this._x0 = x0;\n\t    this._y0 = y0;\n\t    this._x1 = x1;\n\t    this._y1 = y1;\n\t    this._root = undefined;\n\t  }\n\t\n\t  function leaf_copy(leaf) {\n\t    var copy = {data: leaf.data}, next = copy;\n\t    while (leaf = leaf.next) next = next.next = {data: leaf.data};\n\t    return copy;\n\t  }\n\t\n\t  var treeProto = quadtree.prototype = Quadtree.prototype;\n\t\n\t  treeProto.copy = function() {\n\t    var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),\n\t        node = this._root,\n\t        nodes,\n\t        child;\n\t\n\t    if (!node) return copy;\n\t\n\t    if (!node.length) return copy._root = leaf_copy(node), copy;\n\t\n\t    nodes = [{source: node, target: copy._root = new Array(4)}];\n\t    while (node = nodes.pop()) {\n\t      for (var i = 0; i < 4; ++i) {\n\t        if (child = node.source[i]) {\n\t          if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});\n\t          else node.target[i] = leaf_copy(child);\n\t        }\n\t      }\n\t    }\n\t\n\t    return copy;\n\t  };\n\t\n\t  treeProto.add = tree_add;\n\t  treeProto.addAll = addAll;\n\t  treeProto.cover = tree_cover;\n\t  treeProto.data = tree_data;\n\t  treeProto.extent = tree_extent;\n\t  treeProto.find = tree_find;\n\t  treeProto.remove = tree_remove;\n\t  treeProto.removeAll = removeAll;\n\t  treeProto.root = tree_root;\n\t  treeProto.size = tree_size;\n\t  treeProto.visit = tree_visit;\n\t  treeProto.visitAfter = tree_visitAfter;\n\t  treeProto.x = tree_x;\n\t  treeProto.y = tree_y;\n\t\n\t  exports.quadtree = quadtree;\n\t\n\t  Object.defineProperty(exports, '__esModule', { value: true });\n\t\n\t}));\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// https://d3js.org/d3-collection/ Version 1.0.1. Copyright 2016 Mike Bostock.\n\t(function (global, factory) {\n\t   true ? factory(exports) :\n\t  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t  (factory((global.d3 = global.d3 || {})));\n\t}(this, function (exports) { 'use strict';\n\t\n\t  var prefix = \"$\";\n\t\n\t  function Map() {}\n\t\n\t  Map.prototype = map.prototype = {\n\t    constructor: Map,\n\t    has: function(key) {\n\t      return (prefix + key) in this;\n\t    },\n\t    get: function(key) {\n\t      return this[prefix + key];\n\t    },\n\t    set: function(key, value) {\n\t      this[prefix + key] = value;\n\t      return this;\n\t    },\n\t    remove: function(key) {\n\t      var property = prefix + key;\n\t      return property in this && delete this[property];\n\t    },\n\t    clear: function() {\n\t      for (var property in this) if (property[0] === prefix) delete this[property];\n\t    },\n\t    keys: function() {\n\t      var keys = [];\n\t      for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));\n\t      return keys;\n\t    },\n\t    values: function() {\n\t      var values = [];\n\t      for (var property in this) if (property[0] === prefix) values.push(this[property]);\n\t      return values;\n\t    },\n\t    entries: function() {\n\t      var entries = [];\n\t      for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});\n\t      return entries;\n\t    },\n\t    size: function() {\n\t      var size = 0;\n\t      for (var property in this) if (property[0] === prefix) ++size;\n\t      return size;\n\t    },\n\t    empty: function() {\n\t      for (var property in this) if (property[0] === prefix) return false;\n\t      return true;\n\t    },\n\t    each: function(f) {\n\t      for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);\n\t    }\n\t  };\n\t\n\t  function map(object, f) {\n\t    var map = new Map;\n\t\n\t    // Copy constructor.\n\t    if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });\n\t\n\t    // Index array by numeric index or specified key function.\n\t    else if (Array.isArray(object)) {\n\t      var i = -1,\n\t          n = object.length,\n\t          o;\n\t\n\t      if (f == null) while (++i < n) map.set(i, object[i]);\n\t      else while (++i < n) map.set(f(o = object[i], i, object), o);\n\t    }\n\t\n\t    // Convert object to map.\n\t    else if (object) for (var key in object) map.set(key, object[key]);\n\t\n\t    return map;\n\t  }\n\t\n\t  function nest() {\n\t    var keys = [],\n\t        sortKeys = [],\n\t        sortValues,\n\t        rollup,\n\t        nest;\n\t\n\t    function apply(array, depth, createResult, setResult) {\n\t      if (depth >= keys.length) return rollup != null\n\t          ? rollup(array) : (sortValues != null\n\t          ? array.sort(sortValues)\n\t          : array);\n\t\n\t      var i = -1,\n\t          n = array.length,\n\t          key = keys[depth++],\n\t          keyValue,\n\t          value,\n\t          valuesByKey = map(),\n\t          values,\n\t          result = createResult();\n\t\n\t      while (++i < n) {\n\t        if (values = valuesByKey.get(keyValue = key(value = array[i]) + \"\")) {\n\t          values.push(value);\n\t        } else {\n\t          valuesByKey.set(keyValue, [value]);\n\t        }\n\t      }\n\t\n\t      valuesByKey.each(function(values, key) {\n\t        setResult(result, key, apply(values, depth, createResult, setResult));\n\t      });\n\t\n\t      return result;\n\t    }\n\t\n\t    function entries(map, depth) {\n\t      if (++depth > keys.length) return map;\n\t      var array, sortKey = sortKeys[depth - 1];\n\t      if (rollup != null && depth >= keys.length) array = map.entries();\n\t      else array = [], map.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });\n\t      return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;\n\t    }\n\t\n\t    return nest = {\n\t      object: function(array) { return apply(array, 0, createObject, setObject); },\n\t      map: function(array) { return apply(array, 0, createMap, setMap); },\n\t      entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },\n\t      key: function(d) { keys.push(d); return nest; },\n\t      sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },\n\t      sortValues: function(order) { sortValues = order; return nest; },\n\t      rollup: function(f) { rollup = f; return nest; }\n\t    };\n\t  }\n\t\n\t  function createObject() {\n\t    return {};\n\t  }\n\t\n\t  function setObject(object, key, value) {\n\t    object[key] = value;\n\t  }\n\t\n\t  function createMap() {\n\t    return map();\n\t  }\n\t\n\t  function setMap(map, key, value) {\n\t    map.set(key, value);\n\t  }\n\t\n\t  function Set() {}\n\t\n\t  var proto = map.prototype;\n\t\n\t  Set.prototype = set.prototype = {\n\t    constructor: Set,\n\t    has: proto.has,\n\t    add: function(value) {\n\t      value += \"\";\n\t      this[prefix + value] = value;\n\t      return this;\n\t    },\n\t    remove: proto.remove,\n\t    clear: proto.clear,\n\t    values: proto.keys,\n\t    size: proto.size,\n\t    empty: proto.empty,\n\t    each: proto.each\n\t  };\n\t\n\t  function set(object, f) {\n\t    var set = new Set;\n\t\n\t    // Copy constructor.\n\t    if (object instanceof Set) object.each(function(value) { set.add(value); });\n\t\n\t    // Otherwise, assume it’s an array.\n\t    else if (object) {\n\t      var i = -1, n = object.length;\n\t      if (f == null) while (++i < n) set.add(object[i]);\n\t      else while (++i < n) set.add(f(object[i], i, object));\n\t    }\n\t\n\t    return set;\n\t  }\n\t\n\t  function keys(map) {\n\t    var keys = [];\n\t    for (var key in map) keys.push(key);\n\t    return keys;\n\t  }\n\t\n\t  function values(map) {\n\t    var values = [];\n\t    for (var key in map) values.push(map[key]);\n\t    return values;\n\t  }\n\t\n\t  function entries(map) {\n\t    var entries = [];\n\t    for (var key in map) entries.push({key: key, value: map[key]});\n\t    return entries;\n\t  }\n\t\n\t  exports.nest = nest;\n\t  exports.set = set;\n\t  exports.map = map;\n\t  exports.keys = keys;\n\t  exports.values = values;\n\t  exports.entries = entries;\n\t\n\t  Object.defineProperty(exports, '__esModule', { value: true });\n\t\n\t}));\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// https://d3js.org/d3-dispatch/ Version 1.0.1. Copyright 2016 Mike Bostock.\n\t(function (global, factory) {\n\t   true ? factory(exports) :\n\t  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t  (factory((global.d3 = global.d3 || {})));\n\t}(this, function (exports) { 'use strict';\n\t\n\t  var noop = {value: function() {}};\n\t\n\t  function dispatch() {\n\t    for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {\n\t      if (!(t = arguments[i] + \"\") || (t in _)) throw new Error(\"illegal type: \" + t);\n\t      _[t] = [];\n\t    }\n\t    return new Dispatch(_);\n\t  }\n\t\n\t  function Dispatch(_) {\n\t    this._ = _;\n\t  }\n\t\n\t  function parseTypenames(typenames, types) {\n\t    return typenames.trim().split(/^|\\s+/).map(function(t) {\n\t      var name = \"\", i = t.indexOf(\".\");\n\t      if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);\n\t      if (t && !types.hasOwnProperty(t)) throw new Error(\"unknown type: \" + t);\n\t      return {type: t, name: name};\n\t    });\n\t  }\n\t\n\t  Dispatch.prototype = dispatch.prototype = {\n\t    constructor: Dispatch,\n\t    on: function(typename, callback) {\n\t      var _ = this._,\n\t          T = parseTypenames(typename + \"\", _),\n\t          t,\n\t          i = -1,\n\t          n = T.length;\n\t\n\t      // If no callback was specified, return the callback of the given type and name.\n\t      if (arguments.length < 2) {\n\t        while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;\n\t        return;\n\t      }\n\t\n\t      // If a type was specified, set the callback for the given type and name.\n\t      // Otherwise, if a null callback was specified, remove callbacks of the given name.\n\t      if (callback != null && typeof callback !== \"function\") throw new Error(\"invalid callback: \" + callback);\n\t      while (++i < n) {\n\t        if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);\n\t        else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);\n\t      }\n\t\n\t      return this;\n\t    },\n\t    copy: function() {\n\t      var copy = {}, _ = this._;\n\t      for (var t in _) copy[t] = _[t].slice();\n\t      return new Dispatch(copy);\n\t    },\n\t    call: function(type, that) {\n\t      if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];\n\t      if (!this._.hasOwnProperty(type)) throw new Error(\"unknown type: \" + type);\n\t      for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);\n\t    },\n\t    apply: function(type, that, args) {\n\t      if (!this._.hasOwnProperty(type)) throw new Error(\"unknown type: \" + type);\n\t      for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);\n\t    }\n\t  };\n\t\n\t  function get(type, name) {\n\t    for (var i = 0, n = type.length, c; i < n; ++i) {\n\t      if ((c = type[i]).name === name) {\n\t        return c.value;\n\t      }\n\t    }\n\t  }\n\t\n\t  function set(type, name, callback) {\n\t    for (var i = 0, n = type.length; i < n; ++i) {\n\t      if (type[i].name === name) {\n\t        type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));\n\t        break;\n\t      }\n\t    }\n\t    if (callback != null) type.push({name: name, value: callback});\n\t    return type;\n\t  }\n\t\n\t  exports.dispatch = dispatch;\n\t\n\t  Object.defineProperty(exports, '__esModule', { value: true });\n\t\n\t}));\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// https://d3js.org/d3-timer/ Version 1.0.2. Copyright 2016 Mike Bostock.\n\t(function (global, factory) {\n\t   true ? factory(exports) :\n\t  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t  (factory((global.d3 = global.d3 || {})));\n\t}(this, function (exports) { 'use strict';\n\t\n\t  var frame = 0;\n\t  var timeout = 0;\n\t  var interval = 0;\n\t  var pokeDelay = 1000;\n\t  var taskHead;\n\t  var taskTail;\n\t  var clockLast = 0;\n\t  var clockNow = 0;\n\t  var clockSkew = 0;\n\t  var clock = typeof performance === \"object\" && performance.now ? performance : Date;\n\t  var setFrame = typeof requestAnimationFrame === \"function\"\n\t          ? (clock === Date ? function(f) { requestAnimationFrame(function() { f(clock.now()); }); } : requestAnimationFrame)\n\t          : function(f) { setTimeout(f, 17); };\n\t  function now() {\n\t    return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);\n\t  }\n\t\n\t  function clearNow() {\n\t    clockNow = 0;\n\t  }\n\t\n\t  function Timer() {\n\t    this._call =\n\t    this._time =\n\t    this._next = null;\n\t  }\n\t\n\t  Timer.prototype = timer.prototype = {\n\t    constructor: Timer,\n\t    restart: function(callback, delay, time) {\n\t      if (typeof callback !== \"function\") throw new TypeError(\"callback is not a function\");\n\t      time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);\n\t      if (!this._next && taskTail !== this) {\n\t        if (taskTail) taskTail._next = this;\n\t        else taskHead = this;\n\t        taskTail = this;\n\t      }\n\t      this._call = callback;\n\t      this._time = time;\n\t      sleep();\n\t    },\n\t    stop: function() {\n\t      if (this._call) {\n\t        this._call = null;\n\t        this._time = Infinity;\n\t        sleep();\n\t      }\n\t    }\n\t  };\n\t\n\t  function timer(callback, delay, time) {\n\t    var t = new Timer;\n\t    t.restart(callback, delay, time);\n\t    return t;\n\t  }\n\t\n\t  function timerFlush() {\n\t    now(); // Get the current time, if not already set.\n\t    ++frame; // Pretend we’ve set an alarm, if we haven’t already.\n\t    var t = taskHead, e;\n\t    while (t) {\n\t      if ((e = clockNow - t._time) >= 0) t._call.call(null, e);\n\t      t = t._next;\n\t    }\n\t    --frame;\n\t  }\n\t\n\t  function wake(time) {\n\t    clockNow = (clockLast = time || clock.now()) + clockSkew;\n\t    frame = timeout = 0;\n\t    try {\n\t      timerFlush();\n\t    } finally {\n\t      frame = 0;\n\t      nap();\n\t      clockNow = 0;\n\t    }\n\t  }\n\t\n\t  function poke() {\n\t    var now = clock.now(), delay = now - clockLast;\n\t    if (delay > pokeDelay) clockSkew -= delay, clockLast = now;\n\t  }\n\t\n\t  function nap() {\n\t    var t0, t1 = taskHead, t2, time = Infinity;\n\t    while (t1) {\n\t      if (t1._call) {\n\t        if (time > t1._time) time = t1._time;\n\t        t0 = t1, t1 = t1._next;\n\t      } else {\n\t        t2 = t1._next, t1._next = null;\n\t        t1 = t0 ? t0._next = t2 : taskHead = t2;\n\t      }\n\t    }\n\t    taskTail = t0;\n\t    sleep(time);\n\t  }\n\t\n\t  function sleep(time) {\n\t    if (frame) return; // Soonest alarm already set, or will be.\n\t    if (timeout) timeout = clearTimeout(timeout);\n\t    var delay = time - clockNow;\n\t    if (delay > 24) {\n\t      if (time < Infinity) timeout = setTimeout(wake, delay);\n\t      if (interval) interval = clearInterval(interval);\n\t    } else {\n\t      if (!interval) interval = setInterval(poke, pokeDelay);\n\t      frame = 1, setFrame(wake);\n\t    }\n\t  }\n\t\n\t  function timeout$1(callback, delay, time) {\n\t    var t = new Timer;\n\t    delay = delay == null ? 0 : +delay;\n\t    t.restart(function(elapsed) {\n\t      t.stop();\n\t      callback(elapsed + delay);\n\t    }, delay, time);\n\t    return t;\n\t  }\n\t\n\t  function interval$1(callback, delay, time) {\n\t    var t = new Timer, total = delay;\n\t    if (delay == null) return t.restart(callback, delay, time), t;\n\t    delay = +delay, time = time == null ? now() : +time;\n\t    t.restart(function tick(elapsed) {\n\t      elapsed += total;\n\t      t.restart(tick, total += delay, time);\n\t      callback(elapsed);\n\t    }, delay, time);\n\t    return t;\n\t  }\n\t\n\t  exports.now = now;\n\t  exports.timer = timer;\n\t  exports.timerFlush = timerFlush;\n\t  exports.timeout = timeout$1;\n\t  exports.interval = interval$1;\n\t\n\t  Object.defineProperty(exports, '__esModule', { value: true });\n\t\n\t}));\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"nodes\": [\n\t\t\t{\n\t\t\t\t\"id\": \"A\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"id\": \"B\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"id\": \"C\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"id\": \"D\"\n\t\t\t}\n\t\t],\n\t\t\"links\": [\n\t\t\t{\n\t\t\t\t\"source\": \"A\",\n\t\t\t\t\"target\": \"B\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"source\": \"A\",\n\t\t\t\t\"target\": \"C\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"source\": \"A\",\n\t\t\t\t\"target\": \"D\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"source\": \"B\",\n\t\t\t\t\"target\": \"D\"\n\t\t\t}\n\t\t]\n\t};\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Giraph = function () {\n\t\n\t  /* Create an instance of a Giraph \n\t   *\n\t   */\n\t  function Giraph(options) {\n\t    _classCallCheck(this, Giraph);\n\t\n\t    this.options = options;\n\t  }\n\t\n\t  _createClass(Giraph, [{\n\t    key: \"render\",\n\t    value: function render() {\n\t      // TODO\n\t    }\n\t  }]);\n\t\n\t  return Giraph;\n\t}();\n\t\n\tmodule.exports = Giraph;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** giraph.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 2898af064a9d1187eedd\n **/","// Currently this require here adds side effects\nrequire('./js/app.js');\n\n// Main export\nmodule.exports = require('./js/giraph.js');\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/bundle.js\n **/","var d3    = require('d3-force');\nvar graph = require('./data.json');\n\nvar canvas = document.createElement('canvas');\ndocument.body.appendChild(canvas);\n\nvar canvas = document.querySelector(\"canvas\"),\n    context = canvas.getContext(\"2d\"),\n    width = canvas.width,\n    height = canvas.height;\n\nvar simulation = d3.forceSimulation()\n    .force(\"link\", d3.forceLink().id(d => d.id))\n    .force(\"charge\", d3.forceManyBody())\n    .force(\"center\", d3.forceCenter(width / 2, height / 2));\n\nsimulation\n    .nodes(graph.nodes)\n    .on(\"tick\", redraw);\n\nsimulation.force(\"link\")\n    .links(graph.links)\n    .distance(d =>  100);\n\nfunction redraw() {\n  context.clearRect(0, 0, width, height);\n\n  context.beginPath();\n  graph.links.forEach(drawLink);\n  context.stroke();\n\n  context.beginPath();\n  graph.nodes.forEach(drawNode);\n  context.fill();\n}\n\nfunction drawLink(d) {\n  context.moveTo(d.source.x, d.source.y);\n  context.lineTo(d.target.x, d.target.y);\n}\n\nfunction drawNode(d) {\n  context.moveTo(d.x + 3, d.y);\n  context.arc(d.x, d.y, 20, 0, 2 * Math.PI);\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/js/app.js\n **/","// https://d3js.org/d3-force/ Version 1.0.2. Copyright 2016 Mike Bostock.\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-quadtree'), require('d3-collection'), require('d3-dispatch'), require('d3-timer')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'd3-quadtree', 'd3-collection', 'd3-dispatch', 'd3-timer'], factory) :\n  (factory((global.d3 = global.d3 || {}),global.d3,global.d3,global.d3,global.d3));\n}(this, function (exports,d3Quadtree,d3Collection,d3Dispatch,d3Timer) { 'use strict';\n\n  function center(x, y) {\n    var nodes;\n\n    if (x == null) x = 0;\n    if (y == null) y = 0;\n\n    function force() {\n      var i,\n          n = nodes.length,\n          node,\n          sx = 0,\n          sy = 0;\n\n      for (i = 0; i < n; ++i) {\n        node = nodes[i], sx += node.x, sy += node.y;\n      }\n\n      for (sx = sx / n - x, sy = sy / n - y, i = 0; i < n; ++i) {\n        node = nodes[i], node.x -= sx, node.y -= sy;\n      }\n    }\n\n    force.initialize = function(_) {\n      nodes = _;\n    };\n\n    force.x = function(_) {\n      return arguments.length ? (x = +_, force) : x;\n    };\n\n    force.y = function(_) {\n      return arguments.length ? (y = +_, force) : y;\n    };\n\n    return force;\n  }\n\n  function constant(x) {\n    return function() {\n      return x;\n    };\n  }\n\n  function jiggle() {\n    return (Math.random() - 0.5) * 1e-6;\n  }\n\n  function x(d) {\n    return d.x + d.vx;\n  }\n\n  function y(d) {\n    return d.y + d.vy;\n  }\n\n  function collide(radius) {\n    var nodes,\n        radii,\n        strength = 1,\n        iterations = 1;\n\n    if (typeof radius !== \"function\") radius = constant(radius == null ? 1 : +radius);\n\n    function force() {\n      var i, n = nodes.length,\n          tree,\n          node,\n          xi,\n          yi,\n          ri,\n          ri2;\n\n      for (var k = 0; k < iterations; ++k) {\n        tree = d3Quadtree.quadtree(nodes, x, y).visitAfter(prepare);\n        for (i = 0; i < n; ++i) {\n          node = nodes[i];\n          ri = radii[i], ri2 = ri * ri;\n          xi = node.x + node.vx;\n          yi = node.y + node.vy;\n          tree.visit(apply);\n        }\n      }\n\n      function apply(quad, x0, y0, x1, y1) {\n        var data = quad.data, rj = quad.r, r = ri + rj;\n        if (data) {\n          if (data.index > i) {\n            var x = xi - data.x - data.vx,\n                y = yi - data.y - data.vy,\n                l = x * x + y * y;\n            if (l < r * r) {\n              if (x === 0) x = jiggle(), l += x * x;\n              if (y === 0) y = jiggle(), l += y * y;\n              l = (r - (l = Math.sqrt(l))) / l * strength;\n              node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));\n              node.vy += (y *= l) * r;\n              data.vx -= x * (r = 1 - r);\n              data.vy -= y * r;\n            }\n          }\n          return;\n        }\n        return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;\n      }\n    }\n\n    function prepare(quad) {\n      if (quad.data) return quad.r = radii[quad.data.index];\n      for (var i = quad.r = 0; i < 4; ++i) {\n        if (quad[i] && quad[i].r > quad.r) {\n          quad.r = quad[i].r;\n        }\n      }\n    }\n\n    force.initialize = function(_) {\n      var i, n = (nodes = _).length; radii = new Array(n);\n      for (i = 0; i < n; ++i) radii[i] = +radius(nodes[i], i, nodes);\n    };\n\n    force.iterations = function(_) {\n      return arguments.length ? (iterations = +_, force) : iterations;\n    };\n\n    force.strength = function(_) {\n      return arguments.length ? (strength = +_, force) : strength;\n    };\n\n    force.radius = function(_) {\n      return arguments.length ? (radius = typeof _ === \"function\" ? _ : constant(+_), force) : radius;\n    };\n\n    return force;\n  }\n\n  function index(d, i) {\n    return i;\n  }\n\n  function link(links) {\n    var id = index,\n        strength = defaultStrength,\n        strengths,\n        distance = constant(30),\n        distances,\n        nodes,\n        count,\n        bias,\n        iterations = 1;\n\n    if (links == null) links = [];\n\n    function defaultStrength(link) {\n      return 1 / Math.min(count[link.source.index], count[link.target.index]);\n    }\n\n    function force(alpha) {\n      for (var k = 0, n = links.length; k < iterations; ++k) {\n        for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {\n          link = links[i], source = link.source, target = link.target;\n          x = target.x + target.vx - source.x - source.vx || jiggle();\n          y = target.y + target.vy - source.y - source.vy || jiggle();\n          l = Math.sqrt(x * x + y * y);\n          l = (l - distances[i]) / l * alpha * strengths[i];\n          x *= l, y *= l;\n          target.vx -= x * (b = bias[i]);\n          target.vy -= y * b;\n          source.vx += x * (b = 1 - b);\n          source.vy += y * b;\n        }\n      }\n    }\n\n    function initialize() {\n      if (!nodes) return;\n\n      var i,\n          n = nodes.length,\n          m = links.length,\n          nodeById = d3Collection.map(nodes, id),\n          link;\n\n      for (i = 0, count = new Array(n); i < n; ++i) {\n        count[i] = 0;\n      }\n\n      for (i = 0; i < m; ++i) {\n        link = links[i], link.index = i;\n        if (typeof link.source !== \"object\") link.source = nodeById.get(link.source);\n        if (typeof link.target !== \"object\") link.target = nodeById.get(link.target);\n        ++count[link.source.index], ++count[link.target.index];\n      }\n\n      for (i = 0, bias = new Array(m); i < m; ++i) {\n        link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);\n      }\n\n      strengths = new Array(m), initializeStrength();\n      distances = new Array(m), initializeDistance();\n    }\n\n    function initializeStrength() {\n      if (!nodes) return;\n\n      for (var i = 0, n = links.length; i < n; ++i) {\n        strengths[i] = +strength(links[i], i, links);\n      }\n    }\n\n    function initializeDistance() {\n      if (!nodes) return;\n\n      for (var i = 0, n = links.length; i < n; ++i) {\n        distances[i] = +distance(links[i], i, links);\n      }\n    }\n\n    force.initialize = function(_) {\n      nodes = _;\n      initialize();\n    };\n\n    force.links = function(_) {\n      return arguments.length ? (links = _, initialize(), force) : links;\n    };\n\n    force.id = function(_) {\n      return arguments.length ? (id = _, force) : id;\n    };\n\n    force.iterations = function(_) {\n      return arguments.length ? (iterations = +_, force) : iterations;\n    };\n\n    force.strength = function(_) {\n      return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant(+_), initializeStrength(), force) : strength;\n    };\n\n    force.distance = function(_) {\n      return arguments.length ? (distance = typeof _ === \"function\" ? _ : constant(+_), initializeDistance(), force) : distance;\n    };\n\n    return force;\n  }\n\n  function x$1(d) {\n    return d.x;\n  }\n\n  function y$1(d) {\n    return d.y;\n  }\n\n  var initialRadius = 10;\n  var initialAngle = Math.PI * (3 - Math.sqrt(5));\n  function simulation(nodes) {\n    var simulation,\n        alpha = 1,\n        alphaMin = 0.001,\n        alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),\n        alphaTarget = 0,\n        velocityDecay = 0.6,\n        forces = d3Collection.map(),\n        stepper = d3Timer.timer(step),\n        event = d3Dispatch.dispatch(\"tick\", \"end\");\n\n    if (nodes == null) nodes = [];\n\n    function step() {\n      tick();\n      event.call(\"tick\", simulation);\n      if (alpha < alphaMin) {\n        stepper.stop();\n        event.call(\"end\", simulation);\n      }\n    }\n\n    function tick() {\n      var i, n = nodes.length, node;\n\n      alpha += (alphaTarget - alpha) * alphaDecay;\n\n      forces.each(function(force) {\n        force(alpha);\n      });\n\n      for (i = 0; i < n; ++i) {\n        node = nodes[i];\n        if (node.fx == null) node.x += node.vx *= velocityDecay;\n        else node.x = node.fx, node.vx = 0;\n        if (node.fy == null) node.y += node.vy *= velocityDecay;\n        else node.y = node.fy, node.vy = 0;\n      }\n    }\n\n    function initializeNodes() {\n      for (var i = 0, n = nodes.length, node; i < n; ++i) {\n        node = nodes[i], node.index = i;\n        if (isNaN(node.x) || isNaN(node.y)) {\n          var radius = initialRadius * Math.sqrt(i), angle = i * initialAngle;\n          node.x = radius * Math.cos(angle);\n          node.y = radius * Math.sin(angle);\n        }\n        if (isNaN(node.vx) || isNaN(node.vy)) {\n          node.vx = node.vy = 0;\n        }\n      }\n    }\n\n    function initializeForce(force) {\n      if (force.initialize) force.initialize(nodes);\n      return force;\n    }\n\n    initializeNodes();\n\n    return simulation = {\n      tick: tick,\n\n      restart: function() {\n        return stepper.restart(step), simulation;\n      },\n\n      stop: function() {\n        return stepper.stop(), simulation;\n      },\n\n      nodes: function(_) {\n        return arguments.length ? (nodes = _, initializeNodes(), forces.each(initializeForce), simulation) : nodes;\n      },\n\n      alpha: function(_) {\n        return arguments.length ? (alpha = +_, simulation) : alpha;\n      },\n\n      alphaMin: function(_) {\n        return arguments.length ? (alphaMin = +_, simulation) : alphaMin;\n      },\n\n      alphaDecay: function(_) {\n        return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;\n      },\n\n      alphaTarget: function(_) {\n        return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;\n      },\n\n      velocityDecay: function(_) {\n        return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;\n      },\n\n      force: function(name, _) {\n        return arguments.length > 1 ? ((_ == null ? forces.remove(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);\n      },\n\n      find: function(x, y, radius) {\n        var i = 0,\n            n = nodes.length,\n            dx,\n            dy,\n            d2,\n            node,\n            closest;\n\n        if (radius == null) radius = Infinity;\n        else radius *= radius;\n\n        for (i = 0; i < n; ++i) {\n          node = nodes[i];\n          dx = x - node.x;\n          dy = y - node.y;\n          d2 = dx * dx + dy * dy;\n          if (d2 < radius) closest = node, radius = d2;\n        }\n\n        return closest;\n      },\n\n      on: function(name, _) {\n        return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);\n      }\n    };\n  }\n\n  function manyBody() {\n    var nodes,\n        node,\n        alpha,\n        strength = constant(-30),\n        strengths,\n        distanceMin2 = 1,\n        distanceMax2 = Infinity,\n        theta2 = 0.81;\n\n    function force(_) {\n      var i, n = nodes.length, tree = d3Quadtree.quadtree(nodes, x$1, y$1).visitAfter(accumulate);\n      for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);\n    }\n\n    function initialize() {\n      if (!nodes) return;\n      var i, n = nodes.length;\n      strengths = new Array(n);\n      for (i = 0; i < n; ++i) strengths[i] = +strength(nodes[i], i, nodes);\n    }\n\n    function accumulate(quad) {\n      var strength = 0, q, c, x, y, i;\n\n      // For internal nodes, accumulate forces from child quadrants.\n      if (quad.length) {\n        for (x = y = i = 0; i < 4; ++i) {\n          if ((q = quad[i]) && (c = q.value)) {\n            strength += c, x += c * q.x, y += c * q.y;\n          }\n        }\n        quad.x = x / strength;\n        quad.y = y / strength;\n      }\n\n      // For leaf nodes, accumulate forces from coincident quadrants.\n      else {\n        q = quad;\n        q.x = q.data.x;\n        q.y = q.data.y;\n        do strength += strengths[q.data.index];\n        while (q = q.next);\n      }\n\n      quad.value = strength;\n    }\n\n    function apply(quad, x1, _, x2) {\n      if (!quad.value) return true;\n\n      var x = quad.x - node.x,\n          y = quad.y - node.y,\n          w = x2 - x1,\n          l = x * x + y * y;\n\n      // Apply the Barnes-Hut approximation if possible.\n      // Limit forces for very close nodes; randomize direction if coincident.\n      if (w * w / theta2 < l) {\n        if (l < distanceMax2) {\n          if (x === 0) x = jiggle(), l += x * x;\n          if (y === 0) y = jiggle(), l += y * y;\n          if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);\n          node.vx += x * quad.value * alpha / l;\n          node.vy += y * quad.value * alpha / l;\n        }\n        return true;\n      }\n\n      // Otherwise, process points directly.\n      else if (quad.length || l >= distanceMax2) return;\n\n      // Limit forces for very close nodes; randomize direction if coincident.\n      if (quad.data !== node || quad.next) {\n        if (x === 0) x = jiggle(), l += x * x;\n        if (y === 0) y = jiggle(), l += y * y;\n        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);\n      }\n\n      do if (quad.data !== node) {\n        w = strengths[quad.data.index] * alpha / l;\n        node.vx += x * w;\n        node.vy += y * w;\n      } while (quad = quad.next);\n    }\n\n    force.initialize = function(_) {\n      nodes = _;\n      initialize();\n    };\n\n    force.strength = function(_) {\n      return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant(+_), initialize(), force) : strength;\n    };\n\n    force.distanceMin = function(_) {\n      return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);\n    };\n\n    force.distanceMax = function(_) {\n      return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);\n    };\n\n    force.theta = function(_) {\n      return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);\n    };\n\n    return force;\n  }\n\n  function x$2(x) {\n    var strength = constant(0.1),\n        nodes,\n        strengths,\n        xz;\n\n    if (typeof x !== \"function\") x = constant(x == null ? 0 : +x);\n\n    function force(alpha) {\n      for (var i = 0, n = nodes.length, node; i < n; ++i) {\n        node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;\n      }\n    }\n\n    function initialize() {\n      if (!nodes) return;\n      var i, n = nodes.length;\n      strengths = new Array(n);\n      xz = new Array(n);\n      for (i = 0; i < n; ++i) {\n        strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);\n      }\n    }\n\n    force.initialize = function(_) {\n      nodes = _;\n      initialize();\n    };\n\n    force.strength = function(_) {\n      return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant(+_), initialize(), force) : strength;\n    };\n\n    force.x = function(_) {\n      return arguments.length ? (x = typeof _ === \"function\" ? _ : constant(+_), initialize(), force) : x;\n    };\n\n    return force;\n  }\n\n  function y$2(y) {\n    var strength = constant(0.1),\n        nodes,\n        strengths,\n        yz;\n\n    if (typeof y !== \"function\") y = constant(y == null ? 0 : +y);\n\n    function force(alpha) {\n      for (var i = 0, n = nodes.length, node; i < n; ++i) {\n        node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;\n      }\n    }\n\n    function initialize() {\n      if (!nodes) return;\n      var i, n = nodes.length;\n      strengths = new Array(n);\n      yz = new Array(n);\n      for (i = 0; i < n; ++i) {\n        strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);\n      }\n    }\n\n    force.initialize = function(_) {\n      nodes = _;\n      initialize();\n    };\n\n    force.strength = function(_) {\n      return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant(+_), initialize(), force) : strength;\n    };\n\n    force.y = function(_) {\n      return arguments.length ? (y = typeof _ === \"function\" ? _ : constant(+_), initialize(), force) : y;\n    };\n\n    return force;\n  }\n\n  exports.forceCenter = center;\n  exports.forceCollide = collide;\n  exports.forceLink = link;\n  exports.forceManyBody = manyBody;\n  exports.forceSimulation = simulation;\n  exports.forceX = x$2;\n  exports.forceY = y$2;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/d3-force/build/d3-force.js\n ** module id = 2\n ** module chunks = 0\n **/","// https://d3js.org/d3-quadtree/ Version 1.0.1. Copyright 2016 Mike Bostock.\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.d3 = global.d3 || {})));\n}(this, function (exports) { 'use strict';\n\n  function tree_add(d) {\n    var x = +this._x.call(null, d),\n        y = +this._y.call(null, d);\n    return add(this.cover(x, y), x, y, d);\n  }\n\n  function add(tree, x, y, d) {\n    if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points\n\n    var parent,\n        node = tree._root,\n        leaf = {data: d},\n        x0 = tree._x0,\n        y0 = tree._y0,\n        x1 = tree._x1,\n        y1 = tree._y1,\n        xm,\n        ym,\n        xp,\n        yp,\n        right,\n        bottom,\n        i,\n        j;\n\n    // If the tree is empty, initialize the root as a leaf.\n    if (!node) return tree._root = leaf, tree;\n\n    // Find the existing leaf for the new point, or add it.\n    while (node.length) {\n      if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;\n      if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;\n      if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;\n    }\n\n    // Is the new point is exactly coincident with the existing point?\n    xp = +tree._x.call(null, node.data);\n    yp = +tree._y.call(null, node.data);\n    if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;\n\n    // Otherwise, split the leaf node until the old and new point are separated.\n    do {\n      parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);\n      if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;\n      if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;\n    } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));\n    return parent[j] = node, parent[i] = leaf, tree;\n  }\n\n  function addAll(data) {\n    var d, i, n = data.length,\n        x,\n        y,\n        xz = new Array(n),\n        yz = new Array(n),\n        x0 = Infinity,\n        y0 = Infinity,\n        x1 = -Infinity,\n        y1 = -Infinity;\n\n    // Compute the points and their extent.\n    for (i = 0; i < n; ++i) {\n      if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;\n      xz[i] = x;\n      yz[i] = y;\n      if (x < x0) x0 = x;\n      if (x > x1) x1 = x;\n      if (y < y0) y0 = y;\n      if (y > y1) y1 = y;\n    }\n\n    // If there were no (valid) points, inherit the existing extent.\n    if (x1 < x0) x0 = this._x0, x1 = this._x1;\n    if (y1 < y0) y0 = this._y0, y1 = this._y1;\n\n    // Expand the tree to cover the new points.\n    this.cover(x0, y0).cover(x1, y1);\n\n    // Add the new points.\n    for (i = 0; i < n; ++i) {\n      add(this, xz[i], yz[i], data[i]);\n    }\n\n    return this;\n  }\n\n  function tree_cover(x, y) {\n    if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points\n\n    var x0 = this._x0,\n        y0 = this._y0,\n        x1 = this._x1,\n        y1 = this._y1;\n\n    // If the quadtree has no extent, initialize them.\n    // Integer extent are necessary so that if we later double the extent,\n    // the existing quadrant boundaries don’t change due to floating point error!\n    if (isNaN(x0)) {\n      x1 = (x0 = Math.floor(x)) + 1;\n      y1 = (y0 = Math.floor(y)) + 1;\n    }\n\n    // Otherwise, double repeatedly to cover.\n    else if (x0 > x || x > x1 || y0 > y || y > y1) {\n      var z = x1 - x0,\n          node = this._root,\n          parent,\n          i;\n\n      switch (i = (y < (y0 + y1) / 2) << 1 | (x < (x0 + x1) / 2)) {\n        case 0: {\n          do parent = new Array(4), parent[i] = node, node = parent;\n          while (z *= 2, x1 = x0 + z, y1 = y0 + z, x > x1 || y > y1);\n          break;\n        }\n        case 1: {\n          do parent = new Array(4), parent[i] = node, node = parent;\n          while (z *= 2, x0 = x1 - z, y1 = y0 + z, x0 > x || y > y1);\n          break;\n        }\n        case 2: {\n          do parent = new Array(4), parent[i] = node, node = parent;\n          while (z *= 2, x1 = x0 + z, y0 = y1 - z, x > x1 || y0 > y);\n          break;\n        }\n        case 3: {\n          do parent = new Array(4), parent[i] = node, node = parent;\n          while (z *= 2, x0 = x1 - z, y0 = y1 - z, x0 > x || y0 > y);\n          break;\n        }\n      }\n\n      if (this._root && this._root.length) this._root = node;\n    }\n\n    // If the quadtree covers the point already, just return.\n    else return this;\n\n    this._x0 = x0;\n    this._y0 = y0;\n    this._x1 = x1;\n    this._y1 = y1;\n    return this;\n  }\n\n  function tree_data() {\n    var data = [];\n    this.visit(function(node) {\n      if (!node.length) do data.push(node.data); while (node = node.next)\n    });\n    return data;\n  }\n\n  function tree_extent(_) {\n    return arguments.length\n        ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])\n        : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];\n  }\n\n  function Quad(node, x0, y0, x1, y1) {\n    this.node = node;\n    this.x0 = x0;\n    this.y0 = y0;\n    this.x1 = x1;\n    this.y1 = y1;\n  }\n\n  function tree_find(x, y, radius) {\n    var data,\n        x0 = this._x0,\n        y0 = this._y0,\n        x1,\n        y1,\n        x2,\n        y2,\n        x3 = this._x1,\n        y3 = this._y1,\n        quads = [],\n        node = this._root,\n        q,\n        i;\n\n    if (node) quads.push(new Quad(node, x0, y0, x3, y3));\n    if (radius == null) radius = Infinity;\n    else {\n      x0 = x - radius, y0 = y - radius;\n      x3 = x + radius, y3 = y + radius;\n      radius *= radius;\n    }\n\n    while (q = quads.pop()) {\n\n      // Stop searching if this quadrant can’t contain a closer node.\n      if (!(node = q.node)\n          || (x1 = q.x0) > x3\n          || (y1 = q.y0) > y3\n          || (x2 = q.x1) < x0\n          || (y2 = q.y1) < y0) continue;\n\n      // Bisect the current quadrant.\n      if (node.length) {\n        var xm = (x1 + x2) / 2,\n            ym = (y1 + y2) / 2;\n\n        quads.push(\n          new Quad(node[3], xm, ym, x2, y2),\n          new Quad(node[2], x1, ym, xm, y2),\n          new Quad(node[1], xm, y1, x2, ym),\n          new Quad(node[0], x1, y1, xm, ym)\n        );\n\n        // Visit the closest quadrant first.\n        if (i = (y >= ym) << 1 | (x >= xm)) {\n          q = quads[quads.length - 1];\n          quads[quads.length - 1] = quads[quads.length - 1 - i];\n          quads[quads.length - 1 - i] = q;\n        }\n      }\n\n      // Visit this point. (Visiting coincident points isn’t necessary!)\n      else {\n        var dx = x - +this._x.call(null, node.data),\n            dy = y - +this._y.call(null, node.data),\n            d2 = dx * dx + dy * dy;\n        if (d2 < radius) {\n          var d = Math.sqrt(radius = d2);\n          x0 = x - d, y0 = y - d;\n          x3 = x + d, y3 = y + d;\n          data = node.data;\n        }\n      }\n    }\n\n    return data;\n  }\n\n  function tree_remove(d) {\n    if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points\n\n    var parent,\n        node = this._root,\n        retainer,\n        previous,\n        next,\n        x0 = this._x0,\n        y0 = this._y0,\n        x1 = this._x1,\n        y1 = this._y1,\n        x,\n        y,\n        xm,\n        ym,\n        right,\n        bottom,\n        i,\n        j;\n\n    // If the tree is empty, initialize the root as a leaf.\n    if (!node) return this;\n\n    // Find the leaf node for the point.\n    // While descending, also retain the deepest parent with a non-removed sibling.\n    if (node.length) while (true) {\n      if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;\n      if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;\n      if (!(parent = node, node = node[i = bottom << 1 | right])) return this;\n      if (!node.length) break;\n      if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;\n    }\n\n    // Find the point to remove.\n    while (node.data !== d) if (!(previous = node, node = node.next)) return this;\n    if (next = node.next) delete node.next;\n\n    // If there are multiple coincident points, remove just the point.\n    if (previous) return (next ? previous.next = next : delete previous.next), this;\n\n    // If this is the root point, remove it.\n    if (!parent) return this._root = next, this;\n\n    // Remove this leaf.\n    next ? parent[i] = next : delete parent[i];\n\n    // If the parent now contains exactly one leaf, collapse superfluous parents.\n    if ((node = parent[0] || parent[1] || parent[2] || parent[3])\n        && node === (parent[3] || parent[2] || parent[1] || parent[0])\n        && !node.length) {\n      if (retainer) retainer[j] = node;\n      else this._root = node;\n    }\n\n    return this;\n  }\n\n  function removeAll(data) {\n    for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);\n    return this;\n  }\n\n  function tree_root() {\n    return this._root;\n  }\n\n  function tree_size() {\n    var size = 0;\n    this.visit(function(node) {\n      if (!node.length) do ++size; while (node = node.next)\n    });\n    return size;\n  }\n\n  function tree_visit(callback) {\n    var quads = [], q, node = this._root, child, x0, y0, x1, y1;\n    if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));\n    while (q = quads.pop()) {\n      if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {\n        var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;\n        if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));\n        if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));\n        if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));\n        if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));\n      }\n    }\n    return this;\n  }\n\n  function tree_visitAfter(callback) {\n    var quads = [], next = [], q;\n    if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));\n    while (q = quads.pop()) {\n      var node = q.node;\n      if (node.length) {\n        var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;\n        if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));\n        if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));\n        if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));\n        if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));\n      }\n      next.push(q);\n    }\n    while (q = next.pop()) {\n      callback(q.node, q.x0, q.y0, q.x1, q.y1);\n    }\n    return this;\n  }\n\n  function defaultX(d) {\n    return d[0];\n  }\n\n  function tree_x(_) {\n    return arguments.length ? (this._x = _, this) : this._x;\n  }\n\n  function defaultY(d) {\n    return d[1];\n  }\n\n  function tree_y(_) {\n    return arguments.length ? (this._y = _, this) : this._y;\n  }\n\n  function quadtree(nodes, x, y) {\n    var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);\n    return nodes == null ? tree : tree.addAll(nodes);\n  }\n\n  function Quadtree(x, y, x0, y0, x1, y1) {\n    this._x = x;\n    this._y = y;\n    this._x0 = x0;\n    this._y0 = y0;\n    this._x1 = x1;\n    this._y1 = y1;\n    this._root = undefined;\n  }\n\n  function leaf_copy(leaf) {\n    var copy = {data: leaf.data}, next = copy;\n    while (leaf = leaf.next) next = next.next = {data: leaf.data};\n    return copy;\n  }\n\n  var treeProto = quadtree.prototype = Quadtree.prototype;\n\n  treeProto.copy = function() {\n    var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),\n        node = this._root,\n        nodes,\n        child;\n\n    if (!node) return copy;\n\n    if (!node.length) return copy._root = leaf_copy(node), copy;\n\n    nodes = [{source: node, target: copy._root = new Array(4)}];\n    while (node = nodes.pop()) {\n      for (var i = 0; i < 4; ++i) {\n        if (child = node.source[i]) {\n          if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});\n          else node.target[i] = leaf_copy(child);\n        }\n      }\n    }\n\n    return copy;\n  };\n\n  treeProto.add = tree_add;\n  treeProto.addAll = addAll;\n  treeProto.cover = tree_cover;\n  treeProto.data = tree_data;\n  treeProto.extent = tree_extent;\n  treeProto.find = tree_find;\n  treeProto.remove = tree_remove;\n  treeProto.removeAll = removeAll;\n  treeProto.root = tree_root;\n  treeProto.size = tree_size;\n  treeProto.visit = tree_visit;\n  treeProto.visitAfter = tree_visitAfter;\n  treeProto.x = tree_x;\n  treeProto.y = tree_y;\n\n  exports.quadtree = quadtree;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/d3-quadtree/build/d3-quadtree.js\n ** module id = 3\n ** module chunks = 0\n **/","// https://d3js.org/d3-collection/ Version 1.0.1. Copyright 2016 Mike Bostock.\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.d3 = global.d3 || {})));\n}(this, function (exports) { 'use strict';\n\n  var prefix = \"$\";\n\n  function Map() {}\n\n  Map.prototype = map.prototype = {\n    constructor: Map,\n    has: function(key) {\n      return (prefix + key) in this;\n    },\n    get: function(key) {\n      return this[prefix + key];\n    },\n    set: function(key, value) {\n      this[prefix + key] = value;\n      return this;\n    },\n    remove: function(key) {\n      var property = prefix + key;\n      return property in this && delete this[property];\n    },\n    clear: function() {\n      for (var property in this) if (property[0] === prefix) delete this[property];\n    },\n    keys: function() {\n      var keys = [];\n      for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));\n      return keys;\n    },\n    values: function() {\n      var values = [];\n      for (var property in this) if (property[0] === prefix) values.push(this[property]);\n      return values;\n    },\n    entries: function() {\n      var entries = [];\n      for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});\n      return entries;\n    },\n    size: function() {\n      var size = 0;\n      for (var property in this) if (property[0] === prefix) ++size;\n      return size;\n    },\n    empty: function() {\n      for (var property in this) if (property[0] === prefix) return false;\n      return true;\n    },\n    each: function(f) {\n      for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);\n    }\n  };\n\n  function map(object, f) {\n    var map = new Map;\n\n    // Copy constructor.\n    if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });\n\n    // Index array by numeric index or specified key function.\n    else if (Array.isArray(object)) {\n      var i = -1,\n          n = object.length,\n          o;\n\n      if (f == null) while (++i < n) map.set(i, object[i]);\n      else while (++i < n) map.set(f(o = object[i], i, object), o);\n    }\n\n    // Convert object to map.\n    else if (object) for (var key in object) map.set(key, object[key]);\n\n    return map;\n  }\n\n  function nest() {\n    var keys = [],\n        sortKeys = [],\n        sortValues,\n        rollup,\n        nest;\n\n    function apply(array, depth, createResult, setResult) {\n      if (depth >= keys.length) return rollup != null\n          ? rollup(array) : (sortValues != null\n          ? array.sort(sortValues)\n          : array);\n\n      var i = -1,\n          n = array.length,\n          key = keys[depth++],\n          keyValue,\n          value,\n          valuesByKey = map(),\n          values,\n          result = createResult();\n\n      while (++i < n) {\n        if (values = valuesByKey.get(keyValue = key(value = array[i]) + \"\")) {\n          values.push(value);\n        } else {\n          valuesByKey.set(keyValue, [value]);\n        }\n      }\n\n      valuesByKey.each(function(values, key) {\n        setResult(result, key, apply(values, depth, createResult, setResult));\n      });\n\n      return result;\n    }\n\n    function entries(map, depth) {\n      if (++depth > keys.length) return map;\n      var array, sortKey = sortKeys[depth - 1];\n      if (rollup != null && depth >= keys.length) array = map.entries();\n      else array = [], map.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });\n      return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;\n    }\n\n    return nest = {\n      object: function(array) { return apply(array, 0, createObject, setObject); },\n      map: function(array) { return apply(array, 0, createMap, setMap); },\n      entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },\n      key: function(d) { keys.push(d); return nest; },\n      sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },\n      sortValues: function(order) { sortValues = order; return nest; },\n      rollup: function(f) { rollup = f; return nest; }\n    };\n  }\n\n  function createObject() {\n    return {};\n  }\n\n  function setObject(object, key, value) {\n    object[key] = value;\n  }\n\n  function createMap() {\n    return map();\n  }\n\n  function setMap(map, key, value) {\n    map.set(key, value);\n  }\n\n  function Set() {}\n\n  var proto = map.prototype;\n\n  Set.prototype = set.prototype = {\n    constructor: Set,\n    has: proto.has,\n    add: function(value) {\n      value += \"\";\n      this[prefix + value] = value;\n      return this;\n    },\n    remove: proto.remove,\n    clear: proto.clear,\n    values: proto.keys,\n    size: proto.size,\n    empty: proto.empty,\n    each: proto.each\n  };\n\n  function set(object, f) {\n    var set = new Set;\n\n    // Copy constructor.\n    if (object instanceof Set) object.each(function(value) { set.add(value); });\n\n    // Otherwise, assume it’s an array.\n    else if (object) {\n      var i = -1, n = object.length;\n      if (f == null) while (++i < n) set.add(object[i]);\n      else while (++i < n) set.add(f(object[i], i, object));\n    }\n\n    return set;\n  }\n\n  function keys(map) {\n    var keys = [];\n    for (var key in map) keys.push(key);\n    return keys;\n  }\n\n  function values(map) {\n    var values = [];\n    for (var key in map) values.push(map[key]);\n    return values;\n  }\n\n  function entries(map) {\n    var entries = [];\n    for (var key in map) entries.push({key: key, value: map[key]});\n    return entries;\n  }\n\n  exports.nest = nest;\n  exports.set = set;\n  exports.map = map;\n  exports.keys = keys;\n  exports.values = values;\n  exports.entries = entries;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/d3-collection/build/d3-collection.js\n ** module id = 4\n ** module chunks = 0\n **/","// https://d3js.org/d3-dispatch/ Version 1.0.1. Copyright 2016 Mike Bostock.\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.d3 = global.d3 || {})));\n}(this, function (exports) { 'use strict';\n\n  var noop = {value: function() {}};\n\n  function dispatch() {\n    for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {\n      if (!(t = arguments[i] + \"\") || (t in _)) throw new Error(\"illegal type: \" + t);\n      _[t] = [];\n    }\n    return new Dispatch(_);\n  }\n\n  function Dispatch(_) {\n    this._ = _;\n  }\n\n  function parseTypenames(typenames, types) {\n    return typenames.trim().split(/^|\\s+/).map(function(t) {\n      var name = \"\", i = t.indexOf(\".\");\n      if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);\n      if (t && !types.hasOwnProperty(t)) throw new Error(\"unknown type: \" + t);\n      return {type: t, name: name};\n    });\n  }\n\n  Dispatch.prototype = dispatch.prototype = {\n    constructor: Dispatch,\n    on: function(typename, callback) {\n      var _ = this._,\n          T = parseTypenames(typename + \"\", _),\n          t,\n          i = -1,\n          n = T.length;\n\n      // If no callback was specified, return the callback of the given type and name.\n      if (arguments.length < 2) {\n        while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;\n        return;\n      }\n\n      // If a type was specified, set the callback for the given type and name.\n      // Otherwise, if a null callback was specified, remove callbacks of the given name.\n      if (callback != null && typeof callback !== \"function\") throw new Error(\"invalid callback: \" + callback);\n      while (++i < n) {\n        if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);\n        else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);\n      }\n\n      return this;\n    },\n    copy: function() {\n      var copy = {}, _ = this._;\n      for (var t in _) copy[t] = _[t].slice();\n      return new Dispatch(copy);\n    },\n    call: function(type, that) {\n      if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];\n      if (!this._.hasOwnProperty(type)) throw new Error(\"unknown type: \" + type);\n      for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);\n    },\n    apply: function(type, that, args) {\n      if (!this._.hasOwnProperty(type)) throw new Error(\"unknown type: \" + type);\n      for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);\n    }\n  };\n\n  function get(type, name) {\n    for (var i = 0, n = type.length, c; i < n; ++i) {\n      if ((c = type[i]).name === name) {\n        return c.value;\n      }\n    }\n  }\n\n  function set(type, name, callback) {\n    for (var i = 0, n = type.length; i < n; ++i) {\n      if (type[i].name === name) {\n        type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));\n        break;\n      }\n    }\n    if (callback != null) type.push({name: name, value: callback});\n    return type;\n  }\n\n  exports.dispatch = dispatch;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/d3-dispatch/build/d3-dispatch.js\n ** module id = 5\n ** module chunks = 0\n **/","// https://d3js.org/d3-timer/ Version 1.0.2. Copyright 2016 Mike Bostock.\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.d3 = global.d3 || {})));\n}(this, function (exports) { 'use strict';\n\n  var frame = 0;\n  var timeout = 0;\n  var interval = 0;\n  var pokeDelay = 1000;\n  var taskHead;\n  var taskTail;\n  var clockLast = 0;\n  var clockNow = 0;\n  var clockSkew = 0;\n  var clock = typeof performance === \"object\" && performance.now ? performance : Date;\n  var setFrame = typeof requestAnimationFrame === \"function\"\n          ? (clock === Date ? function(f) { requestAnimationFrame(function() { f(clock.now()); }); } : requestAnimationFrame)\n          : function(f) { setTimeout(f, 17); };\n  function now() {\n    return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);\n  }\n\n  function clearNow() {\n    clockNow = 0;\n  }\n\n  function Timer() {\n    this._call =\n    this._time =\n    this._next = null;\n  }\n\n  Timer.prototype = timer.prototype = {\n    constructor: Timer,\n    restart: function(callback, delay, time) {\n      if (typeof callback !== \"function\") throw new TypeError(\"callback is not a function\");\n      time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);\n      if (!this._next && taskTail !== this) {\n        if (taskTail) taskTail._next = this;\n        else taskHead = this;\n        taskTail = this;\n      }\n      this._call = callback;\n      this._time = time;\n      sleep();\n    },\n    stop: function() {\n      if (this._call) {\n        this._call = null;\n        this._time = Infinity;\n        sleep();\n      }\n    }\n  };\n\n  function timer(callback, delay, time) {\n    var t = new Timer;\n    t.restart(callback, delay, time);\n    return t;\n  }\n\n  function timerFlush() {\n    now(); // Get the current time, if not already set.\n    ++frame; // Pretend we’ve set an alarm, if we haven’t already.\n    var t = taskHead, e;\n    while (t) {\n      if ((e = clockNow - t._time) >= 0) t._call.call(null, e);\n      t = t._next;\n    }\n    --frame;\n  }\n\n  function wake(time) {\n    clockNow = (clockLast = time || clock.now()) + clockSkew;\n    frame = timeout = 0;\n    try {\n      timerFlush();\n    } finally {\n      frame = 0;\n      nap();\n      clockNow = 0;\n    }\n  }\n\n  function poke() {\n    var now = clock.now(), delay = now - clockLast;\n    if (delay > pokeDelay) clockSkew -= delay, clockLast = now;\n  }\n\n  function nap() {\n    var t0, t1 = taskHead, t2, time = Infinity;\n    while (t1) {\n      if (t1._call) {\n        if (time > t1._time) time = t1._time;\n        t0 = t1, t1 = t1._next;\n      } else {\n        t2 = t1._next, t1._next = null;\n        t1 = t0 ? t0._next = t2 : taskHead = t2;\n      }\n    }\n    taskTail = t0;\n    sleep(time);\n  }\n\n  function sleep(time) {\n    if (frame) return; // Soonest alarm already set, or will be.\n    if (timeout) timeout = clearTimeout(timeout);\n    var delay = time - clockNow;\n    if (delay > 24) {\n      if (time < Infinity) timeout = setTimeout(wake, delay);\n      if (interval) interval = clearInterval(interval);\n    } else {\n      if (!interval) interval = setInterval(poke, pokeDelay);\n      frame = 1, setFrame(wake);\n    }\n  }\n\n  function timeout$1(callback, delay, time) {\n    var t = new Timer;\n    delay = delay == null ? 0 : +delay;\n    t.restart(function(elapsed) {\n      t.stop();\n      callback(elapsed + delay);\n    }, delay, time);\n    return t;\n  }\n\n  function interval$1(callback, delay, time) {\n    var t = new Timer, total = delay;\n    if (delay == null) return t.restart(callback, delay, time), t;\n    delay = +delay, time = time == null ? now() : +time;\n    t.restart(function tick(elapsed) {\n      elapsed += total;\n      t.restart(tick, total += delay, time);\n      callback(elapsed);\n    }, delay, time);\n    return t;\n  }\n\n  exports.now = now;\n  exports.timer = timer;\n  exports.timerFlush = timerFlush;\n  exports.timeout = timeout$1;\n  exports.interval = interval$1;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/d3-timer/build/d3-timer.js\n ** module id = 6\n ** module chunks = 0\n **/","module.exports = {\n\t\"nodes\": [\n\t\t{\n\t\t\t\"id\": \"A\"\n\t\t},\n\t\t{\n\t\t\t\"id\": \"B\"\n\t\t},\n\t\t{\n\t\t\t\"id\": \"C\"\n\t\t},\n\t\t{\n\t\t\t\"id\": \"D\"\n\t\t}\n\t],\n\t\"links\": [\n\t\t{\n\t\t\t\"source\": \"A\",\n\t\t\t\"target\": \"B\"\n\t\t},\n\t\t{\n\t\t\t\"source\": \"A\",\n\t\t\t\"target\": \"C\"\n\t\t},\n\t\t{\n\t\t\t\"source\": \"A\",\n\t\t\t\"target\": \"D\"\n\t\t},\n\t\t{\n\t\t\t\"source\": \"B\",\n\t\t\t\"target\": \"D\"\n\t\t}\n\t]\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/js/data.json\n ** module id = 7\n ** module chunks = 0\n **/","class Giraph {\n\n  /* Create an instance of a Giraph \n   *\n   */\n  constructor(options) {\n    this.options = options;\n  }\n\n  render() {\n    // TODO\n  }\n  \n}\n\nmodule.exports = Giraph; \n\n\n\n/** WEBPACK FOOTER **\n ** ./src/js/giraph.js\n **/"],"sourceRoot":""}